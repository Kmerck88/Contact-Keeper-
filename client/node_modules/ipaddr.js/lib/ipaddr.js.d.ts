<<<<<<< HEAD
declare module "ipaddr.js" {
=======


declare module "ipaddr.js" {

>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    type IPv4Range = 'unicast' | 'unspecified' | 'broadcast' | 'multicast' | 'linkLocal' | 'loopback' | 'carrierGradeNat' | 'private' | 'reserved';
    type IPv6Range = 'unicast' | 'unspecified' | 'linkLocal' | 'multicast' | 'loopback' | 'uniqueLocal' | 'ipv4Mapped' | 'rfc6145' | 'rfc6052' | '6to4' | 'teredo' | 'reserved';

    interface RangeList<T> {
        [name: string]: [T, number] | [T, number][];
    }

<<<<<<< HEAD
    // Common methods/properties for IPv4 and IPv6 classes.
    class IP {
        prefixLengthFromSubnetMask(): number | null;
=======

    // Common methods/properties for IPv4 and IPv6 classes.
    class IP {

        prefixLengthFromSubnetMask(): number | false;
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        toByteArray(): number[];
        toNormalizedString(): string;
        toString(): string;
    }

    namespace Address {
<<<<<<< HEAD
=======

>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        export function isValid(addr: string): boolean;
        export function fromByteArray(bytes: number[]): IPv4 | IPv6;
        export function parse(addr: string): IPv4 | IPv6;
        export function parseCIDR(mask: string): [IPv4 | IPv6, number];
<<<<<<< HEAD
        export function process(addr: string): IPv4 | IPv6;
=======
        export function process(address: string): IPv4 | IPv6;
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        export function subnetMatch(addr: IPv4, rangeList: RangeList<IPv4>, defaultName?: string): string;
        export function subnetMatch(addr: IPv6, rangeList: RangeList<IPv6>, defaultName?: string): string;

        export class IPv4 extends IP {
            static broadcastAddressFromCIDR(addr: string): IPv4;
            static isIPv4(addr: string): boolean;
            static isValidFourPartDecimal(addr: string): boolean;
            static isValid(addr: string): boolean;
            static networkAddressFromCIDR(addr: string): IPv4;
            static parse(addr: string): IPv4;
            static parseCIDR(addr: string): [IPv4, number];
            static subnetMaskFromPrefixLength(prefix: number): IPv4;
            constructor(octets: number[]);
<<<<<<< HEAD
            octets: number[]
=======
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0

            kind(): 'ipv4';
            match(addr: IPv4, bits: number): boolean;
            match(mask: [IPv4, number]): boolean;
            range(): IPv4Range;
            subnetMatch(rangeList: RangeList<IPv4>, defaultName?: string): string;
            toIPv4MappedAddress(): IPv6;
        }

        export class IPv6 extends IP {
            static broadcastAddressFromCIDR(addr: string): IPv6;
            static isIPv6(addr: string): boolean;
            static isValid(addr: string): boolean;
            static parse(addr: string): IPv6;
            static parseCIDR(addr: string): [IPv6, number];
            static subnetMaskFromPrefixLength(prefix: number): IPv6;
<<<<<<< HEAD
            constructor(parts: number[]);
            parts: number[]
            zoneId?: string
=======
            constructor(octets: number[]);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0

            isIPv4MappedAddress(): boolean;
            kind(): 'ipv6';
            match(addr: IPv6, bits: number): boolean;
            match(mask: [IPv6, number]): boolean;
            range(): IPv6Range;
            subnetMatch(rangeList: RangeList<IPv6>, defaultName?: string): string;
            toIPv4Address(): IPv4;
        }
    }

    export = Address;
}
