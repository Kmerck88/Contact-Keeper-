{"ast":null,"code":"// config.js (c) 2010-2015 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-config\n// Dependencies\nvar deferConfig = require('../defer').deferConfig,\n    DeferredConfig = require('../defer').DeferredConfig,\n    RawConfig = require('../raw').RawConfig,\n    Parser = require('../parser'),\n    Utils = require('util'),\n    Path = require('path'),\n    FileSystem = require('fs'); // Static members\n\n\nvar DEFAULT_CLONE_DEPTH = 20,\n    NODE_CONFIG,\n    CONFIG_DIR,\n    RUNTIME_JSON_FILENAME,\n    NODE_ENV,\n    APP_INSTANCE,\n    HOST,\n    HOSTNAME,\n    ALLOW_CONFIG_MUTATIONS,\n    CONFIG_SKIP_GITCRYPT,\n    NODE_CONFIG_PARSER,\n    env = {},\n    privateUtil = {},\n    deprecationWarnings = {},\n    configSources = [],\n    // Configuration sources - array of {name, original, parsed}\ncheckMutability = true,\n    // Check for mutability/immutability on first get\ngitCryptTestRegex = /^.GITCRYPT/; // regular expression to test for gitcrypt files.\n\n/**\n * <p>Application Configurations</p>\n *\n * <p>\n * The config module exports a singleton object representing all\n * configurations for this application deployment.\n * </p>\n *\n * <p>\n * Application configurations are stored in files within the config directory\n * of your application.  The default configuration file is loaded, followed\n * by files specific to the deployment type (development, testing, staging,\n * production, etc.).\n * </p>\n *\n * <p>\n * For example, with the following config/default.yaml file:\n * </p>\n *\n * <pre>\n *   ...\n *   customer:\n *     &nbsp;&nbsp;initialCredit: 500\n *     &nbsp;&nbsp;db:\n *       &nbsp;&nbsp;&nbsp;&nbsp;name: customer\n *       &nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n *   ...\n * </pre>\n *\n * <p>\n * The following code loads the customer section into the CONFIG variable:\n * <p>\n *\n * <pre>\n *   var CONFIG = require('config').customer;\n *   ...\n *   newCustomer.creditLimit = CONFIG.initialCredit;\n *   database.open(CONFIG.db.name, CONFIG.db.port);\n *   ...\n * </pre>\n *\n * @module config\n * @class Config\n */\n\n/**\n * <p>Get the configuration object.</p>\n *\n * <p>\n * The configuration object is a shared singleton object within the application,\n * attained by calling require('config').\n * </p>\n *\n * <p>\n * Usually you'll specify a CONFIG variable at the top of your .js file\n * for file/module scope. If you want the root of the object, you can do this:\n * </p>\n * <pre>\n * var CONFIG = require('config');\n * </pre>\n *\n * <p>\n * Sometimes you only care about a specific sub-object within the CONFIG\n * object.  In that case you could do this at the top of your file:\n * </p>\n * <pre>\n * var CONFIG = require('config').customer;\n * or\n * var CUSTOMER_CONFIG = require('config').customer;\n * </pre>\n *\n * <script type=\"text/javascript\">\n *   document.getElementById(\"showProtected\").style.display = \"block\";\n * </script>\n *\n * @method constructor\n * @return CONFIG {object} - The top level configuration object\n */\n\nvar Config = function () {\n  var t = this; // Bind all utility functions to this\n\n  for (var fnName in util) {\n    if (typeof util[fnName] === 'function') {\n      util[fnName] = util[fnName].bind(t);\n    }\n  } // Merge configurations into this\n\n\n  util.extendDeep(t, util.loadFileConfigs());\n  util.attachProtoDeep(t); // Perform strictness checks and possibly throw an exception.\n\n  util.runStrictnessChecks(t);\n};\n/**\n * Utilities are under the util namespace vs. at the top level\n */\n\n\nvar util = Config.prototype.util = {};\n/**\n * Underlying get mechanism\n *\n * @private\n * @method getImpl\n * @param object {object} - Object to get the property for\n * @param property {string|string[]} - The property name to get (as an array or '.' delimited string)\n * @return value {*} - Property value, including undefined if not defined.\n */\n\nvar getImpl = function (object, property) {\n  var t = this,\n      elems = Array.isArray(property) ? property : property.split('.'),\n      name = elems[0],\n      value = object[name];\n\n  if (elems.length <= 1) {\n    return value;\n  } // Note that typeof null === 'object'\n\n\n  if (value === null || typeof value !== 'object') {\n    return undefined;\n  }\n\n  return getImpl(value, elems.slice(1));\n};\n/**\n * <p>Get a configuration value</p>\n *\n * <p>\n * This will return the specified property value, throwing an exception if the\n * configuration isn't defined.  It is used to assure configurations are defined\n * before being used, and to prevent typos.\n * </p>\n *\n * @method get\n * @param property {string} - The configuration property to get. Can include '.' sub-properties.\n * @return value {*} - The property value\n */\n\n\nConfig.prototype.get = function (property) {\n  if (property === null || property === undefined) {\n    throw new Error(\"Calling config.get with null or undefined argument\");\n  } // Make configurations immutable after first get (unless disabled)\n\n\n  if (checkMutability) {\n    if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n      util.makeImmutable(config);\n    }\n\n    checkMutability = false;\n  }\n\n  var t = this,\n      value = getImpl(t, property); // Produce an exception if the property doesn't exist\n\n  if (value === undefined) {\n    throw new Error('Configuration property \"' + property + '\" is not defined');\n  } // Return the value\n\n\n  return value;\n};\n/**\n * Test that a configuration parameter exists\n *\n * <pre>\n *    var config = require('config');\n *    if (config.has('customer.dbName')) {\n *      console.log('Customer database name: ' + config.customer.dbName);\n *    }\n * </pre>\n *\n * @method has\n * @param property {string} - The configuration property to test. Can include '.' sub-properties.\n * @return isPresent {boolean} - True if the property is defined, false if not defined.\n */\n\n\nConfig.prototype.has = function (property) {\n  // While get() throws an exception for undefined input, has() is designed to test validity, so false is appropriate\n  if (property === null || property === undefined) {\n    return false;\n  }\n\n  var t = this;\n  return getImpl(t, property) !== undefined;\n};\n/**\n * <p>\n * Set default configurations for a node.js module.\n * </p>\n *\n * <p>\n * This allows module developers to attach their configurations onto the\n * default configuration object so they can be configured by the consumers\n * of the module.\n * </p>\n *\n * <p>Using the function within your module:</p>\n * <pre>\n *   var CONFIG = require(\"config\");\n *   CONFIG.util.setModuleDefaults(\"MyModule\", {\n *   &nbsp;&nbsp;templateName: \"t-50\",\n *   &nbsp;&nbsp;colorScheme: \"green\"\n *   });\n * <br>\n *   // Template name may be overridden by application config files\n *   console.log(\"Template: \" + CONFIG.MyModule.templateName);\n * </pre>\n *\n * <p>\n * The above example results in a \"MyModule\" element of the configuration\n * object, containing an object with the specified default values.\n * </p>\n *\n * @method setModuleDefaults\n * @param moduleName {string} - Name of your module.\n * @param defaultProperties {object} - The default module configuration.\n * @return moduleConfig {object} - The module level configuration object.\n */\n\n\nutil.setModuleDefaults = function (moduleName, defaultProperties) {\n  // Copy the properties into a new object\n  var t = this,\n      moduleConfig = util.cloneDeep(defaultProperties); // Set module defaults into the first sources element\n\n  if (configSources.length === 0 || configSources[0].name !== 'Module Defaults') {\n    configSources.splice(0, 0, {\n      name: 'Module Defaults',\n      parsed: {}\n    });\n  }\n\n  util.setPath(configSources[0].parsed, moduleName.split('.'), {});\n  util.extendDeep(getImpl(configSources[0].parsed, moduleName), defaultProperties); // Create a top level config for this module if it doesn't exist\n\n  util.setPath(t, moduleName.split('.'), getImpl(t, moduleName) || {}); // Extend local configurations into the module config\n\n  util.extendDeep(moduleConfig, getImpl(t, moduleName)); // Merge the extended configs without replacing the original\n\n  util.extendDeep(getImpl(t, moduleName), moduleConfig); // reset the mutability check for \"config.get\" method.\n  // we are not making t[moduleName] immutable immediately,\n  // since there might be more modifications before the first config.get\n\n  if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n    checkMutability = true;\n  } // Attach handlers & watchers onto the module config object\n\n\n  return util.attachProtoDeep(getImpl(t, moduleName));\n};\n/**\n * <p>Make a configuration property hidden so it doesn't appear when enumerating\n * elements of the object.</p>\n *\n * <p>\n * The property still exists and can be read from and written to, but it won't\n * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n * </p>\n *\n * <p>\n * If the property already exists, it will be made hidden.  Otherwise it will\n * be created as a hidden property with the specified value.\n * </p>\n *\n * <p><i>\n * This method was built for hiding configuration values, but it can be applied\n * to <u>any</u> javascript object.\n * </i></p>\n *\n * <p>Example:</p>\n * <pre>\n *   var CONFIG = require('config');\n *   ...\n *\n *   // Hide the Amazon S3 credentials\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'access_id');\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'secret_key');\n * </pre>\n *\n * @method makeHidden\n * @param object {object} - The object to make a hidden property into.\n * @param property {string} - The name of the property to make hidden.\n * @param value {*} - (optional) Set the property value to this (otherwise leave alone)\n * @return object {object} - The original object is returned - for chaining.\n */\n\n\nutil.makeHidden = function (object, property, value) {\n  // If the new value isn't specified, just mark the property as hidden\n  if (typeof value === 'undefined') {\n    Object.defineProperty(object, property, {\n      enumerable: false\n    });\n  } // Otherwise set the value and mark it as hidden\n  else {\n      Object.defineProperty(object, property, {\n        value: value,\n        enumerable: false\n      });\n    }\n\n  return object;\n};\n/**\n * <p>Make a javascript object property immutable (assuring it cannot be changed\n * from the current value).</p>\n * <p>\n * If the specified property is an object, all attributes of that object are\n * made immutable, including properties of contained objects, recursively.\n * If a property name isn't supplied, all properties of the object are made\n * immutable.\n * </p>\n * <p>\n *\n * </p>\n * <p>\n * New properties can be added to the object and those properties will not be\n * immutable unless this method is called on those new properties.\n * </p>\n * <p>\n * This operation cannot be undone.\n * </p>\n *\n * <p>Example:</p>\n * <pre>\n *   var config = require('config');\n *   var myObject = {hello:'world'};\n *   config.util.makeImmutable(myObject);\n * </pre>\n *\n * @method makeImmutable\n * @param object {object} - The object to specify immutable properties for\n * @param [property] {string | [string]} - The name of the property (or array of names) to make immutable.\n *        If not provided, all owned properties of the object are made immutable.\n * @param [value] {* | [*]} - Property value (or array of values) to set\n *        the property to before making immutable. Only used when setting a single\n *        property. Retained for backward compatibility.\n * @return object {object} - The original object is returned - for chaining.\n */\n\n\nutil.makeImmutable = function (object, property, value) {\n  var properties = null; // Backwards compatibility mode where property/value can be specified\n\n  if (typeof property === 'string') {\n    return Object.defineProperty(object, property, {\n      value: typeof value === 'undefined' ? object[property] : value,\n      writable: false,\n      configurable: false\n    });\n  } // Get the list of properties to work with\n\n\n  if (Array.isArray(property)) {\n    properties = property;\n  } else {\n    properties = Object.keys(object);\n  } // Process each property\n\n\n  for (var i = 0; i < properties.length; i++) {\n    var propertyName = properties[i],\n        value = object[propertyName];\n\n    if (value instanceof RawConfig) {\n      Object.defineProperty(object, propertyName, {\n        value: value.resolve(),\n        writable: false,\n        configurable: false\n      });\n    } else if (Array.isArray(value)) {\n      // Ensure object items of this array are also immutable.\n      value.forEach((item, index) => {\n        if (util.isObject(item) || Array.isArray(item)) util.makeImmutable(item);\n      });\n      Object.defineProperty(object, propertyName, {\n        value: Object.freeze(value)\n      });\n    } else {\n      Object.defineProperty(object, propertyName, {\n        value: value,\n        writable: false,\n        configurable: false\n      }); // Ensure new properties can not be added.\n\n      Object.preventExtensions(object); // Call recursively if an object.\n\n      if (util.isObject(value)) {\n        util.makeImmutable(value);\n      }\n    }\n  }\n\n  return object;\n};\n/**\n * Return the sources for the configurations\n *\n * <p>\n * All sources for configurations are stored in an array of objects containing\n * the source name (usually the filename), the original source (as a string),\n * and the parsed source as an object.\n * </p>\n *\n * @method getConfigSources\n * @return configSources {Array[Object]} - An array of objects containing\n *    name, original, and parsed elements\n */\n\n\nutil.getConfigSources = function () {\n  var t = this;\n  return configSources.slice(0);\n};\n/**\n * Load the individual file configurations.\n *\n * <p>\n * This method builds a map of filename to the configuration object defined\n * by the file.  The search order is:\n * </p>\n *\n * <pre>\n *   default.EXT\n *   (deployment).EXT\n *   (hostname).EXT\n *   (hostname)-(deployment).EXT\n *   local.EXT\n *   local-(deployment).EXT\n *   runtime.json\n * </pre>\n *\n * <p>\n * EXT can be yml, yaml, coffee, iced, json, cson or js signifying the file type.\n * yaml (and yml) is in YAML format, coffee is a coffee-script, iced is iced-coffee-script,\n * json is in JSON format, cson is in CSON format, properties is in .properties format\n * (http://en.wikipedia.org/wiki/.properties), and js is a javascript executable file that is\n * require()'d with module.exports being the config object.\n * </p>\n *\n * <p>\n * hostname is the $HOST environment variable (or --HOST command line parameter)\n * if set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\n * line parameter) if set, otherwise the hostname found from\n * require('os').hostname().\n * </p>\n *\n * <p>\n * Once a hostname is found, everything from the first period ('.') onwards\n * is removed. For example, abc.example.com becomes abc\n * </p>\n *\n * <p>\n * (deployment) is the deployment type, found in the $NODE_ENV environment\n * variable (which can be overriden by using $NODE_CONFIG_ENV\n * environment variable). Defaults to 'development'.\n * </p>\n *\n * <p>\n * The runtime.json file contains configuration changes made at runtime either\n * manually, or by the application setting a configuration value.\n * </p>\n *\n * <p>\n * If the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\n * command line parameter) is set, then files with this appendage will be loaded.\n * See the Multiple Application Instances section of the main documentaion page\n * for more information.\n * </p>\n *\n * @protected\n * @method loadFileConfigs\n * @return config {Object} The configuration object\n */\n\n\nutil.loadFileConfigs = function (configDir) {\n  // Initialize\n  var t = this,\n      config = {}; // Initialize parameters from command line, environment, or default\n\n  NODE_ENV = util.initParam('NODE_ENV', 'development'); // Override, NODE_ENV if NODE_CONFIG_ENV is specified.\n\n  NODE_ENV = util.initParam('NODE_CONFIG_ENV', NODE_ENV); // Split files name, for loading multiple files.\n\n  NODE_ENV = NODE_ENV.split(',');\n  CONFIG_DIR = configDir || util.initParam('NODE_CONFIG_DIR', Path.join(process.cwd(), 'config'));\n\n  if (CONFIG_DIR.indexOf('.') === 0) {\n    CONFIG_DIR = Path.join(process.cwd(), CONFIG_DIR);\n  }\n\n  APP_INSTANCE = util.initParam('NODE_APP_INSTANCE');\n  HOST = util.initParam('HOST');\n  HOSTNAME = util.initParam('HOSTNAME');\n  CONFIG_SKIP_GITCRYPT = util.initParam('CONFIG_SKIP_GITCRYPT'); // This is for backward compatibility\n\n  RUNTIME_JSON_FILENAME = util.initParam('NODE_CONFIG_RUNTIME_JSON', Path.join(CONFIG_DIR, 'runtime.json'));\n  NODE_CONFIG_PARSER = util.initParam('NODE_CONFIG_PARSER');\n\n  if (NODE_CONFIG_PARSER) {\n    try {\n      var parserModule = Path.isAbsolute(NODE_CONFIG_PARSER) ? NODE_CONFIG_PARSER : Path.join(CONFIG_DIR, NODE_CONFIG_PARSER);\n      Parser = require(parserModule);\n    } catch (e) {\n      console.warn('Failed to load config parser from ' + NODE_CONFIG_PARSER);\n      console.log(e);\n    }\n  } // Determine the host name from the OS module, $HOST, or $HOSTNAME\n  // Remove any . appendages, and default to null if not set\n\n\n  try {\n    var hostName = HOST || HOSTNAME;\n\n    if (!hostName) {\n      var OS = require('os');\n\n      hostName = OS.hostname();\n    }\n  } catch (e) {\n    hostName = '';\n  } // Store the hostname that won.\n\n\n  env.HOSTNAME = hostName; // Read each file in turn\n\n  var baseNames = ['default'].concat(NODE_ENV); // #236: Also add full hostname when they are different.\n\n  if (hostName) {\n    var firstDomain = hostName.split('.')[0];\n    NODE_ENV.forEach(function (env) {\n      // Backward compatibility\n      baseNames.push(firstDomain, firstDomain + '-' + env); // Add full hostname when it is not the same\n\n      if (hostName !== firstDomain) {\n        baseNames.push(hostName, hostName + '-' + env);\n      }\n    });\n  }\n\n  NODE_ENV.forEach(function (env) {\n    baseNames.push('local', 'local-' + env);\n  });\n  var allowedFiles = {};\n  var resolutionIndex = 1;\n  var extNames = Parser.getFilesOrder();\n  baseNames.forEach(function (baseName) {\n    extNames.forEach(function (extName) {\n      allowedFiles[baseName + '.' + extName] = resolutionIndex++;\n\n      if (APP_INSTANCE) {\n        allowedFiles[baseName + '-' + APP_INSTANCE + '.' + extName] = resolutionIndex++;\n      }\n    });\n  });\n  var locatedFiles = util.locateMatchingFiles(CONFIG_DIR, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename);\n\n    if (configObj) {\n      util.extendDeep(config, configObj);\n    }\n  }); // Override configurations from the $NODE_CONFIG environment variable\n  // NODE_CONFIG only applies to the base config\n\n  if (!configDir) {\n    var envConfig = {};\n\n    if (process.env.NODE_CONFIG) {\n      try {\n        envConfig = JSON.parse(process.env.NODE_CONFIG);\n      } catch (e) {\n        console.error('The $NODE_CONFIG environment variable is malformed JSON');\n      }\n\n      util.extendDeep(config, envConfig);\n      configSources.push({\n        name: \"$NODE_CONFIG\",\n        parsed: envConfig\n      });\n    } // Override configurations from the --NODE_CONFIG command line\n\n\n    var cmdLineConfig = util.getCmdLineArg('NODE_CONFIG');\n\n    if (cmdLineConfig) {\n      try {\n        cmdLineConfig = JSON.parse(cmdLineConfig);\n      } catch (e) {\n        console.error('The --NODE_CONFIG={json} command line argument is malformed JSON');\n      }\n\n      util.extendDeep(config, cmdLineConfig);\n      configSources.push({\n        name: \"--NODE_CONFIG argument\",\n        parsed: cmdLineConfig\n      });\n    } // Place the mixed NODE_CONFIG into the environment\n\n\n    env['NODE_CONFIG'] = JSON.stringify(util.extendDeep(envConfig, cmdLineConfig, {}));\n  } // Override with environment variables if there is a custom-environment-variables.EXT mapping file\n\n\n  var customEnvVars = util.getCustomEnvVars(CONFIG_DIR, extNames);\n  util.extendDeep(config, customEnvVars); // Extend the original config with the contents of runtime.json (backwards compatibility)\n\n  var runtimeJson = util.parseFile(RUNTIME_JSON_FILENAME) || {};\n  util.extendDeep(config, runtimeJson);\n  util.resolveDeferredConfigs(config); // Return the configuration object\n\n  return config;\n};\n/**\n * Return a list of fullFilenames who exists in allowedFiles\n * Ordered according to allowedFiles argument specifications\n *\n * @protected\n * @method locateMatchingFiles\n * @param configDirs {string}   the config dir, or multiple dirs separated by a column (:)\n * @param allowedFiles {object} an object. keys and supported filenames\n *                              and values are the position in the resolution order\n * @returns {string[]}          fullFilenames - path + filename\n */\n\n\nutil.locateMatchingFiles = function (configDirs, allowedFiles) {\n  return configDirs.split(Path.delimiter).reduce(function (files, configDir) {\n    if (configDir) {\n      try {\n        FileSystem.readdirSync(configDir).forEach(function (file) {\n          if (allowedFiles[file]) {\n            files.push([allowedFiles[file], Path.join(configDir, file)]);\n          }\n        });\n      } catch (e) {}\n\n      return files;\n    }\n  }, []).sort(function (a, b) {\n    return a[0] - b[0];\n  }).map(function (file) {\n    return file[1];\n  });\n}; // Using basic recursion pattern, find all the deferred values and resolve them.\n\n\nutil.resolveDeferredConfigs = function (config) {\n  var deferred = [];\n\n  function _iterate(prop) {\n    // We put the properties we are going to look it in an array to keep the order predictable\n    var propsToSort = []; // First step is to put the properties of interest in an array\n\n    for (var property in prop) {\n      if (prop.hasOwnProperty(property) && prop[property] != null) {\n        propsToSort.push(property);\n      }\n    } // Second step is to iterate of the elements in a predictable (sorted) order\n\n\n    propsToSort.sort().forEach(function (property) {\n      if (prop[property].constructor === Object) {\n        _iterate(prop[property]);\n      } else if (prop[property].constructor === Array) {\n        for (var i = 0; i < prop[property].length; i++) {\n          if (prop[property][i] instanceof DeferredConfig) {\n            deferred.push(prop[property][i].prepare(config, prop[property], i));\n          } else {\n            _iterate(prop[property][i]);\n          }\n        }\n      } else {\n        if (prop[property] instanceof DeferredConfig) {\n          deferred.push(prop[property].prepare(config, prop, property));\n        } // else: Nothing to do. Keep the property how it is.\n\n      }\n    });\n  }\n\n  _iterate(config);\n\n  deferred.forEach(function (defer) {\n    defer.resolve();\n  });\n};\n/**\n * Parse and return the specified configuration file.\n *\n * If the file exists in the application config directory, it will\n * parse and return it as a JavaScript object.\n *\n * The file extension determines the parser to use.\n *\n * .js = File to run that has a module.exports containing the config object\n * .coffee = File to run that has a module.exports with coffee-script containing the config object\n * .iced = File to run that has a module.exports with iced-coffee-script containing the config object\n * All other supported file types (yaml, toml, json, cson, hjson, json5, properties, xml)\n * are parsed with util.parseString.\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseFile\n * @param fullFilename {string} The full file path and name\n * @return configObject {object|null} The configuration object parsed from the file\n */\n\n\nutil.parseFile = function (fullFilename) {\n  var t = this,\n      // Initialize\n  configObject = null,\n      fileContent = null,\n      stat = null; // Note that all methods here are the Sync versions.  This is appropriate during\n  // module loading (which is a synchronous operation), but not thereafter.\n\n  try {\n    // Try loading the file.\n    fileContent = FileSystem.readFileSync(fullFilename, 'utf-8');\n    fileContent = fileContent.replace(/^\\uFEFF/, '');\n  } catch (e2) {\n    if (e2.code !== 'ENOENT') {\n      throw new Error('Config file ' + fullFilename + ' cannot be read. Error code is: ' + e2.code + '. Error message is: ' + e2.message);\n    }\n\n    return null; // file doesn't exists\n  } // Parse the file based on extension\n\n\n  try {\n    // skip if it's a gitcrypt file and CONFIG_SKIP_GITCRYPT is true\n    if (CONFIG_SKIP_GITCRYPT) {\n      if (gitCryptTestRegex.test(fileContent)) {\n        console.error('WARNING: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is set. skipping.');\n        return null;\n      }\n    }\n\n    configObject = Parser.parse(fullFilename, fileContent);\n  } catch (e3) {\n    if (gitCryptTestRegex.test(fileContent)) {\n      console.error('ERROR: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is not set.');\n    }\n\n    throw new Error(\"Cannot parse config file: '\" + fullFilename + \"': \" + e3);\n  } // Keep track of this configuration sources, including empty ones\n\n\n  if (typeof configObject === 'object') {\n    configSources.push({\n      name: fullFilename,\n      original: fileContent,\n      parsed: configObject\n    });\n  }\n\n  return configObject;\n};\n/**\n * Parse and return the specied string with the specified format.\n *\n * The format determines the parser to use.\n *\n * json = File is parsed using JSON.parse()\n * yaml (or yml) = Parsed with a YAML parser\n * toml = Parsed with a TOML parser\n * cson = Parsed with a CSON parser\n * hjson = Parsed with a HJSON parser\n * json5 = Parsed with a JSON5 parser\n * properties = Parsed with the 'properties' node package\n * xml = Parsed with a XML parser\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseString\n * @param content {string} The full content\n * @param format {string} The format to be parsed\n * @return {configObject} The configuration object parsed from the string\n */\n\n\nutil.parseString = function (content, format) {\n  var parser = Parser.getParser(format);\n\n  if (typeof parser === 'function') {\n    return parser(null, content);\n  }\n};\n/**\n * Attach the Config class prototype to all config objects recursively.\n *\n * <p>\n * This allows you to do anything with CONFIG sub-objects as you can do with\n * the top-level CONFIG object.  It's so you can do this:\n * </p>\n *\n * <pre>\n *   var CUST_CONFIG = require('config').Customer;\n *   CUST_CONFIG.get(...)\n * </pre>\n *\n * @protected\n * @method attachProtoDeep\n * @param toObject\n * @param depth\n * @return toObject\n */\n\n\nutil.attachProtoDeep = function (toObject, depth) {\n  if (toObject instanceof RawConfig) {\n    return toObject;\n  } // Recursion detection\n\n\n  var t = this;\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n\n  if (depth < 0) {\n    return toObject;\n  } // Adding Config.prototype methods directly to toObject as hidden properties\n  // because adding to toObject.__proto__ exposes the function in toObject\n\n\n  for (var fnName in Config.prototype) {\n    if (!toObject[fnName]) {\n      util.makeHidden(toObject, fnName, Config.prototype[fnName]);\n    }\n  } // Add prototypes to sub-objects\n\n\n  for (var prop in toObject) {\n    if (util.isObject(toObject[prop])) {\n      util.attachProtoDeep(toObject[prop], depth - 1);\n    }\n  } // Return the original object\n\n\n  return toObject;\n};\n/**\n * Return a deep copy of the specified object.\n *\n * This returns a new object with all elements copied from the specified\n * object.  Deep copies are made of objects and arrays so you can do anything\n * with the returned object without affecting the input object.\n *\n * @protected\n * @method cloneDeep\n * @param parent {object} The original object to copy from\n * @param [depth=20] {Integer} Maximum depth (default 20)\n * @return {object} A new object with the elements copied from the copyFrom object\n *\n * This method is copied from https://github.com/pvorb/node-clone/blob/17eea36140d61d97a9954c53417d0e04a00525d9/clone.js\n *\n * Copyright © 2011-2014 Paul Vorbach and contributors.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions: The above copyright notice and this permission\n * notice shall be included in all copies or substantial portions of the Software.\n */\n\n\nutil.cloneDeep = function cloneDeep(parent, depth, circular, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n  var useBuffer = typeof Buffer != 'undefined';\n  if (typeof circular === 'undefined') circular = true;\n  if (typeof depth === 'undefined') depth = 20; // recurse this function so we don't reset allParents and allChildren\n\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null) return null;\n    if (depth === 0) return parent;\n    var child;\n\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (Utils.isArray(parent)) {\n      child = [];\n    } else if (Utils.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (Utils.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype === 'undefined') child = Object.create(Object.getPrototypeOf(parent));else child = Object.create(prototype);\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var propDescriptor = Object.getOwnPropertyDescriptor(parent, i);\n      var hasGetter = propDescriptor !== undefined && propDescriptor.get !== undefined;\n\n      if (hasGetter) {\n        Object.defineProperty(child, i, propDescriptor);\n      } else if (util.isPromise(parent[i])) {\n        child[i] = parent[i];\n      } else {\n        child[i] = _clone(parent[i], depth - 1);\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n};\n/**\n * Set objects given a path as a string list\n *\n * @protected\n * @method setPath\n * @param object {object} - Object to set the property on\n * @param path {array[string]} - Array path to the property\n * @param value {*} - value to set, ignoring null\n */\n\n\nutil.setPath = function (object, path, value) {\n  var nextKey = null;\n\n  if (value === null || path.length === 0) {\n    return;\n  } else if (path.length === 1) {\n    // no more keys to make, so set the value\n    object[path.shift()] = value;\n  } else {\n    nextKey = path.shift();\n\n    if (!object.hasOwnProperty(nextKey)) {\n      object[nextKey] = {};\n    }\n\n    util.setPath(object[nextKey], path, value);\n  }\n};\n/**\n * Create a new object patterned after substitutionMap, where:\n * 1. Terminal string values in substitutionMap are used as keys\n * 2. To look up values in a key-value store, variables\n * 3. And parent keys are created as necessary to retain the structure of substitutionMap.\n *\n * @protected\n * @method substituteDeep\n * @param substitionMap {object} - an object whose terminal (non-subobject) values are strings\n * @param variables {object[string:value]} - usually process.env, a flat object used to transform\n *      terminal values in a copy of substititionMap.\n * @returns {object} - deep copy of substitutionMap with only those paths whose terminal values\n *      corresponded to a key in `variables`\n */\n\n\nutil.substituteDeep = function (substitutionMap, variables) {\n  var result = {};\n\n  function _substituteVars(map, vars, pathTo) {\n    for (var prop in map) {\n      var value = map[prop];\n\n      if (typeof value === 'string') {\n        // We found a leaf variable name\n        if (vars[value]) {\n          // if the vars provide a value set the value in the result map\n          util.setPath(result, pathTo.concat(prop), vars[value]);\n        }\n      } else if (util.isObject(value)) {\n        // work on the subtree, giving it a clone of the pathTo\n        if ('__name' in value && '__format' in value && vars[value.__name]) {\n          try {\n            var parsedValue = util.parseString(vars[value.__name], value.__format);\n          } catch (err) {\n            err.message = '__format parser error in ' + value.__name + ': ' + err.message;\n            throw err;\n          }\n\n          util.setPath(result, pathTo.concat(prop), parsedValue);\n        } else {\n          _substituteVars(value, vars, pathTo.concat(prop));\n        }\n      } else {\n        msg = \"Illegal key type for substitution map at \" + pathTo.join('.') + ': ' + typeof value;\n        throw Error(msg);\n      }\n    }\n  }\n\n  _substituteVars(substitutionMap, variables, []);\n\n  return result;\n};\n/* Map environment variables into the configuration if a mapping file,\n * `custom-environment-variables.EXT` exists.\n *\n * @protected\n * @method getCustomEnvVars\n * @param CONFIG_DIR {string} - the passsed configuration directory\n * @param extNames {Array[string]} - acceptable configuration file extension names.\n * @returns {object} - mapped environment variables or {} if there are none\n */\n\n\nutil.getCustomEnvVars = function (CONFIG_DIR, extNames) {\n  var result = {};\n  extNames.forEach(function (extName) {\n    var fullFilename = Path.join(CONFIG_DIR, 'custom-environment-variables' + '.' + extName);\n    var configObj = util.parseFile(fullFilename);\n\n    if (configObj) {\n      var environmentSubstitutions = util.substituteDeep(configObj, process.env);\n      util.extendDeep(result, environmentSubstitutions);\n    }\n  });\n  return result;\n};\n/**\n * Return true if two objects have equal contents.\n *\n * @protected\n * @method equalsDeep\n * @param object1 {object} The object to compare from\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {boolean} True if both objects have equivalent contents\n */\n\n\nutil.equalsDeep = function (object1, object2, depth) {\n  // Recursion detection\n  var t = this;\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n\n  if (depth < 0) {\n    return {};\n  } // Fast comparisons\n\n\n  if (!object1 || !object2) {\n    return false;\n  }\n\n  if (object1 === object2) {\n    return true;\n  }\n\n  if (typeof object1 != 'object' || typeof object2 != 'object') {\n    return false;\n  } // They must have the same keys.  If their length isn't the same\n  // then they're not equal.  If the keys aren't the same, the value\n  // comparisons will fail.\n\n\n  if (Object.keys(object1).length != Object.keys(object2).length) {\n    return false;\n  } // Compare the values\n\n\n  for (var prop in object1) {\n    // Call recursively if an object or array\n    if (object1[prop] && typeof object1[prop] === 'object') {\n      if (!util.equalsDeep(object1[prop], object2[prop], depth - 1)) {\n        return false;\n      }\n    } else {\n      if (object1[prop] !== object2[prop]) {\n        return false;\n      }\n    }\n  } // Test passed.\n\n\n  return true;\n};\n/**\n * Returns an object containing all elements that differ between two objects.\n * <p>\n * This method was designed to be used to create the runtime.json file\n * contents, but can be used to get the diffs between any two Javascript objects.\n * </p>\n * <p>\n * It works best when object2 originated by deep copying object1, then\n * changes were made to object2, and you want an object that would give you\n * the changes made to object1 which resulted in object2.\n * </p>\n *\n * @protected\n * @method diffDeep\n * @param object1 {object} The base object to compare to\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} A differential object, which if extended onto object1 would\n *                  result in object2.\n */\n\n\nutil.diffDeep = function (object1, object2, depth) {\n  // Recursion detection\n  var t = this,\n      diff = {};\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n\n  if (depth < 0) {\n    return {};\n  } // Process each element from object2, adding any element that's different\n  // from object 1.\n\n\n  for (var parm in object2) {\n    var value1 = object1[parm];\n    var value2 = object2[parm];\n\n    if (value1 && value2 && util.isObject(value2)) {\n      if (!util.equalsDeep(value1, value2)) {\n        diff[parm] = util.diffDeep(value1, value2, depth - 1);\n      }\n    } else if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (!util.equalsDeep(value1, value2)) {\n        diff[parm] = value2;\n      }\n    } else if (value1 !== value2) {\n      diff[parm] = value2;\n    }\n  } // Return the diff object\n\n\n  return diff;\n};\n/**\n * Extend an object, and any object it contains.\n *\n * This does not replace deep objects, but dives into them\n * replacing individual elements instead.\n *\n * @protected\n * @method extendDeep\n * @param mergeInto {object} The object to merge into\n * @param mergeFrom... {object...} - Any number of objects to merge from\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} The altered mergeInto object is returned\n */\n\n\nutil.extendDeep = function (mergeInto) {\n  // Initialize\n  var t = this;\n  var vargs = Array.prototype.slice.call(arguments, 1);\n  var depth = vargs.pop();\n\n  if (typeof depth != 'number') {\n    vargs.push(depth);\n    depth = DEFAULT_CLONE_DEPTH;\n  } // Recursion detection\n\n\n  if (depth < 0) {\n    return mergeInto;\n  } // Cycle through each object to extend\n\n\n  vargs.forEach(function (mergeFrom) {\n    // Cycle through each element of the object to merge from\n    for (var prop in mergeFrom) {\n      // save original value in deferred elements\n      var fromIsDeferredFunc = mergeFrom[prop] instanceof DeferredConfig;\n      var isDeferredFunc = mergeInto[prop] instanceof DeferredConfig;\n\n      if (fromIsDeferredFunc && mergeInto.hasOwnProperty(prop)) {\n        mergeFrom[prop]._original = isDeferredFunc ? mergeInto[prop]._original : mergeInto[prop];\n      } // Extend recursively if both elements are objects and target is not really a deferred function\n\n\n      if (mergeFrom[prop] instanceof Date) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n\n      if (mergeFrom[prop] instanceof RegExp) {\n        mergeInto[prop] = mergeFrom[prop];\n      } else if (util.isObject(mergeInto[prop]) && util.isObject(mergeFrom[prop]) && !isDeferredFunc) {\n        util.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);\n      } else if (util.isPromise(mergeFrom[prop])) {\n        mergeInto[prop] = mergeFrom[prop];\n      } // Copy recursively if the mergeFrom element is an object (or array or fn)\n      else if (mergeFrom[prop] && typeof mergeFrom[prop] === 'object') {\n          mergeInto[prop] = util.cloneDeep(mergeFrom[prop], depth - 1);\n        } // Copy property descriptor otherwise, preserving accessors\n        else if (Object.getOwnPropertyDescriptor(Object(mergeFrom), prop)) {\n            Object.defineProperty(mergeInto, prop, Object.getOwnPropertyDescriptor(Object(mergeFrom), prop));\n          } else {\n            mergeInto[prop] = mergeFrom[prop];\n          }\n    }\n  }); // Chain\n\n  return mergeInto;\n};\n/**\n * Is the specified argument a regular javascript object?\n *\n * The argument is an object if it's a JS object, but not an array.\n *\n * @protected\n * @method isObject\n * @param obj {*} An argument of any type.\n * @return {boolean} TRUE if the arg is an object, FALSE if not\n */\n\n\nutil.isObject = function (obj) {\n  return obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n};\n/**\n * Is the specified argument a javascript promise?\n *\n * @protected\n * @method isPromise\n * @param obj {*} An argument of any type.\n * @returns {boolean}\n */\n\n\nutil.isPromise = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Promise]';\n};\n/**\n * <p>Initialize a parameter from the command line or process environment</p>\n *\n * <p>\n * This method looks for the parameter from the command line in the format\n * --PARAMETER=VALUE, then from the process environment, then from the\n * default specified as an argument.\n * </p>\n *\n * @method initParam\n * @param paramName {String} Name of the parameter\n * @param [defaultValue] {Any} Default value of the parameter\n * @return {Any} The found value, or default value\n */\n\n\nutil.initParam = function (paramName, defaultValue) {\n  var t = this; // Record and return the value\n\n  var value = util.getCmdLineArg(paramName) || process.env[paramName] || defaultValue;\n  env[paramName] = value;\n  return value;\n};\n/**\n * <p>Get Command Line Arguments</p>\n *\n * <p>\n * This method allows you to retrieve the value of the specified command line argument.\n * </p>\n *\n * <p>\n * The argument is case sensitive, and must be of the form '--ARG_NAME=value'\n * </p>\n *\n * @method getCmdLineArg\n * @param searchFor {String} The argument name to search for\n * @return {*} false if the argument was not found, the argument value if found\n */\n\n\nutil.getCmdLineArg = function (searchFor) {\n  var cmdLineArgs = process.argv.slice(2, process.argv.length),\n      argName = '--' + searchFor + '=';\n\n  for (var argvIt = 0; argvIt < cmdLineArgs.length; argvIt++) {\n    if (cmdLineArgs[argvIt].indexOf(argName) === 0) {\n      return cmdLineArgs[argvIt].substr(argName.length);\n    }\n  }\n\n  return false;\n};\n/**\n * <p>Get a Config Environment Variable Value</p>\n *\n * <p>\n * This method returns the value of the specified config environment variable,\n * including any defaults or overrides.\n * </p>\n *\n * @method getEnv\n * @param varName {String} The environment variable name\n * @return {String} The value of the environment variable\n */\n\n\nutil.getEnv = function (varName) {\n  return env[varName];\n};\n/**\n * Returns a string of flags for regular expression `re`.\n *\n * @param {RegExp} re Regular expression\n * @returns {string} Flags\n */\n\n\nutil.getRegExpFlags = function (re) {\n  var flags = '';\n  re.global && (flags += 'g');\n  re.ignoreCase && (flags += 'i');\n  re.multiline && (flags += 'm');\n  return flags;\n};\n/**\n * Returns a new deep copy of the current config object, or any part of the config if provided.\n *\n * @param {Object} config The part of the config to copy and serialize. Omit this argument to return the entire config.\n * @returns {Object} The cloned config or part of the config\n */\n\n\nutil.toObject = function (config) {\n  return JSON.parse(JSON.stringify(config || this));\n}; // Run strictness checks on NODE_ENV and NODE_APP_INSTANCE and throw an error if there's a problem.\n\n\nutil.runStrictnessChecks = function (config) {\n  var sources = config.util.getConfigSources();\n  var sourceFilenames = sources.map(function (src) {\n    return Path.basename(src.name);\n  });\n  NODE_ENV.forEach(function (env) {\n    // Throw an exception if there's no explicit config file for NODE_ENV\n    var anyFilesMatchEnv = sourceFilenames.some(function (filename) {\n      return filename.match(env);\n    }); // development is special-cased because it's the default value\n\n    if (env && env !== 'development' && !anyFilesMatchEnv) {\n      _warnOrThrow(\"NODE_ENV value of '\" + env + \"' did not match any deployment config file names.\");\n    } // Throw if NODE_ENV matches' default' or 'local'\n\n\n    if (env === 'default' || env === 'local') {\n      _warnOrThrow(\"NODE_ENV value of '\" + env + \"' is ambiguous.\");\n    }\n  }); // Throw an exception if there's no explict config file for NODE_APP_INSTANCE\n\n  var anyFilesMatchInstance = sourceFilenames.some(function (filename) {\n    return filename.match(APP_INSTANCE);\n  });\n\n  if (APP_INSTANCE && !anyFilesMatchInstance) {\n    _warnOrThrow(\"NODE_APP_INSTANCE value of '\" + APP_INSTANCE + \"' did not match any instance config file names.\");\n  }\n\n  function _warnOrThrow(msg) {\n    var beStrict = process.env.NODE_CONFIG_STRICT_MODE;\n    var prefix = beStrict ? 'FATAL: ' : 'WARNING: ';\n    var seeURL = 'See https://github.com/lorenwest/node-config/wiki/Strict-Mode';\n    console.error(prefix + msg);\n    console.error(prefix + seeURL); // Accept 1 and true as truthy values. When set via process.env, Node.js casts them to strings.\n\n    if ([\"true\", \"1\"].indexOf(beStrict) >= 0) {\n      throw new Error(prefix + msg + ' ' + seeURL);\n    }\n  }\n}; // Instantiate and export the configuration\n\n\nvar config = module.exports = new Config(); // copy methods to util for backwards compatibility\n\nutil.stripComments = Parser.stripComments;\nutil.stripYamlComments = Parser.stripYamlComments; // Produce warnings if the configuration is empty\n\nvar showWarnings = !util.initParam('SUPPRESS_NO_CONFIG_WARNING');\n\nif (showWarnings && Object.keys(config).length === 0) {\n  console.error('WARNING: No configurations found in configuration directory:' + CONFIG_DIR);\n  console.error('WARNING: To disable this warning set SUPPRESS_NO_CONFIG_WARNING in the environment.');\n}","map":{"version":3,"sources":["C:/Users/kevin/Documents/Web Development Projects/Contact-Keeper-/node_modules/config/lib/config.js"],"names":["deferConfig","require","DeferredConfig","RawConfig","Parser","Utils","Path","FileSystem","DEFAULT_CLONE_DEPTH","NODE_CONFIG","CONFIG_DIR","RUNTIME_JSON_FILENAME","NODE_ENV","APP_INSTANCE","HOST","HOSTNAME","ALLOW_CONFIG_MUTATIONS","CONFIG_SKIP_GITCRYPT","NODE_CONFIG_PARSER","env","privateUtil","deprecationWarnings","configSources","checkMutability","gitCryptTestRegex","Config","t","fnName","util","bind","extendDeep","loadFileConfigs","attachProtoDeep","runStrictnessChecks","prototype","getImpl","object","property","elems","Array","isArray","split","name","value","length","undefined","slice","get","Error","initParam","makeImmutable","config","has","setModuleDefaults","moduleName","defaultProperties","moduleConfig","cloneDeep","splice","parsed","setPath","makeHidden","Object","defineProperty","enumerable","properties","writable","configurable","keys","i","propertyName","resolve","forEach","item","index","isObject","freeze","preventExtensions","getConfigSources","configDir","join","process","cwd","indexOf","parserModule","isAbsolute","e","console","warn","log","hostName","OS","hostname","baseNames","concat","firstDomain","push","allowedFiles","resolutionIndex","extNames","getFilesOrder","baseName","extName","locatedFiles","locateMatchingFiles","fullFilename","configObj","parseFile","envConfig","JSON","parse","error","cmdLineConfig","getCmdLineArg","stringify","customEnvVars","getCustomEnvVars","runtimeJson","resolveDeferredConfigs","configDirs","delimiter","reduce","files","readdirSync","file","sort","a","b","map","deferred","_iterate","prop","propsToSort","hasOwnProperty","constructor","prepare","defer","configObject","fileContent","stat","readFileSync","replace","e2","code","message","test","e3","original","parseString","content","format","parser","getParser","toObject","depth","parent","circular","allParents","allChildren","useBuffer","Buffer","_clone","child","isRegExp","RegExp","source","getRegExpFlags","lastIndex","isDate","Date","getTime","isBuffer","copy","create","getPrototypeOf","propDescriptor","getOwnPropertyDescriptor","hasGetter","isPromise","path","nextKey","shift","substituteDeep","substitutionMap","variables","result","_substituteVars","vars","pathTo","__name","parsedValue","__format","err","msg","environmentSubstitutions","equalsDeep","object1","object2","diffDeep","diff","parm","value1","value2","mergeInto","vargs","call","arguments","pop","mergeFrom","fromIsDeferredFunc","isDeferredFunc","_original","obj","toString","paramName","defaultValue","searchFor","cmdLineArgs","argv","argName","argvIt","substr","getEnv","varName","re","flags","global","ignoreCase","multiline","sources","sourceFilenames","src","basename","anyFilesMatchEnv","some","filename","match","_warnOrThrow","anyFilesMatchInstance","beStrict","NODE_CONFIG_STRICT_MODE","prefix","seeURL","module","exports","stripComments","stripYamlComments","showWarnings"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AACA,IAAIA,WAAW,GAAGC,OAAO,CAAC,UAAD,CAAP,CAAoBD,WAAtC;AAAA,IACIE,cAAc,GAAGD,OAAO,CAAC,UAAD,CAAP,CAAoBC,cADzC;AAAA,IAEIC,SAAS,GAAGF,OAAO,CAAC,QAAD,CAAP,CAAkBE,SAFlC;AAAA,IAGIC,MAAM,GAAGH,OAAO,CAAC,WAAD,CAHpB;AAAA,IAIII,KAAK,GAAGJ,OAAO,CAAC,MAAD,CAJnB;AAAA,IAKIK,IAAI,GAAGL,OAAO,CAAC,MAAD,CALlB;AAAA,IAMIM,UAAU,GAAGN,OAAO,CAAC,IAAD,CANxB,C,CAQA;;;AACA,IAAIO,mBAAmB,GAAG,EAA1B;AAAA,IACIC,WADJ;AAAA,IACiBC,UADjB;AAAA,IAC6BC,qBAD7B;AAAA,IACoDC,QADpD;AAAA,IAC8DC,YAD9D;AAAA,IAEIC,IAFJ;AAAA,IAEUC,QAFV;AAAA,IAEoBC,sBAFpB;AAAA,IAE4CC,oBAF5C;AAAA,IAGIC,kBAHJ;AAAA,IAIIC,GAAG,GAAG,EAJV;AAAA,IAKIC,WAAW,GAAG,EALlB;AAAA,IAMIC,mBAAmB,GAAG,EAN1B;AAAA,IAOIC,aAAa,GAAG,EAPpB;AAAA,IAOiC;AAC7BC,eAAe,GAAG,IARtB;AAAA,IAQiC;AAC7BC,iBAAiB,GAAG,YATxB,C,CASsC;;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,IAAIC,MAAM,GAAG,YAAW;AACtB,MAAIC,CAAC,GAAG,IAAR,CADsB,CAGtB;;AACA,OAAK,IAAIC,MAAT,IAAmBC,IAAnB,EAAyB;AACvB,QAAI,OAAOA,IAAI,CAACD,MAAD,CAAX,KAAwB,UAA5B,EAAwC;AACtCC,MAAAA,IAAI,CAACD,MAAD,CAAJ,GAAeC,IAAI,CAACD,MAAD,CAAJ,CAAaE,IAAb,CAAkBH,CAAlB,CAAf;AACD;AACF,GARqB,CAUtB;;;AACAE,EAAAA,IAAI,CAACE,UAAL,CAAgBJ,CAAhB,EAAmBE,IAAI,CAACG,eAAL,EAAnB;AACAH,EAAAA,IAAI,CAACI,eAAL,CAAqBN,CAArB,EAZsB,CActB;;AACAE,EAAAA,IAAI,CAACK,mBAAL,CAAyBP,CAAzB;AACD,CAhBD;AAkBA;;;;;AAGA,IAAIE,IAAI,GAAGH,MAAM,CAACS,SAAP,CAAiBN,IAAjB,GAAwB,EAAnC;AAEA;;;;;;;;;;AASA,IAAIO,OAAO,GAAE,UAASC,MAAT,EAAiBC,QAAjB,EAA2B;AACtC,MAAIX,CAAC,GAAG,IAAR;AAAA,MACIY,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcH,QAAd,IAA0BA,QAA1B,GAAqCA,QAAQ,CAACI,KAAT,CAAe,GAAf,CADjD;AAAA,MAEIC,IAAI,GAAGJ,KAAK,CAAC,CAAD,CAFhB;AAAA,MAGIK,KAAK,GAAGP,MAAM,CAACM,IAAD,CAHlB;;AAIA,MAAIJ,KAAK,CAACM,MAAN,IAAgB,CAApB,EAAuB;AACrB,WAAOD,KAAP;AACD,GAPqC,CAQtC;;;AACA,MAAIA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,QAAvC,EAAiD;AAC/C,WAAOE,SAAP;AACD;;AACD,SAAOV,OAAO,CAACQ,KAAD,EAAQL,KAAK,CAACQ,KAAN,CAAY,CAAZ,CAAR,CAAd;AACD,CAbD;AAeA;;;;;;;;;;;;;;;AAaArB,MAAM,CAACS,SAAP,CAAiBa,GAAjB,GAAuB,UAASV,QAAT,EAAmB;AACxC,MAAGA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAKQ,SAArC,EAA+C;AAC7C,UAAM,IAAIG,KAAJ,CAAU,oDAAV,CAAN;AACD,GAHuC,CAKxC;;;AACA,MAAIzB,eAAJ,EAAqB;AACnB,QAAI,CAACK,IAAI,CAACqB,SAAL,CAAe,wBAAf,EAAyC,KAAzC,CAAL,EAAsD;AACpDrB,MAAAA,IAAI,CAACsB,aAAL,CAAmBC,MAAnB;AACD;;AACD5B,IAAAA,eAAe,GAAG,KAAlB;AACD;;AACD,MAAIG,CAAC,GAAG,IAAR;AAAA,MACIiB,KAAK,GAAGR,OAAO,CAACT,CAAD,EAAIW,QAAJ,CADnB,CAZwC,CAexC;;AACA,MAAIM,KAAK,KAAKE,SAAd,EAAyB;AACvB,UAAM,IAAIG,KAAJ,CAAU,6BAA6BX,QAA7B,GAAwC,kBAAlD,CAAN;AACD,GAlBuC,CAoBxC;;;AACA,SAAOM,KAAP;AACD,CAtBD;AAwBA;;;;;;;;;;;;;;;;AAcAlB,MAAM,CAACS,SAAP,CAAiBkB,GAAjB,GAAuB,UAASf,QAAT,EAAmB;AACxC;AACA,MAAGA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAKQ,SAArC,EAA+C;AAC7C,WAAO,KAAP;AACD;;AACD,MAAInB,CAAC,GAAG,IAAR;AACA,SAAQS,OAAO,CAACT,CAAD,EAAIW,QAAJ,CAAP,KAAyBQ,SAAjC;AACD,CAPD;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCAjB,IAAI,CAACyB,iBAAL,GAAyB,UAAUC,UAAV,EAAsBC,iBAAtB,EAAyC;AAEhE;AACA,MAAI7B,CAAC,GAAG,IAAR;AAAA,MACE8B,YAAY,GAAG5B,IAAI,CAAC6B,SAAL,CAAeF,iBAAf,CADjB,CAHgE,CAMhE;;AACA,MAAIjC,aAAa,CAACsB,MAAd,KAAyB,CAAzB,IAA8BtB,aAAa,CAAC,CAAD,CAAb,CAAiBoB,IAAjB,KAA0B,iBAA5D,EAA+E;AAC7EpB,IAAAA,aAAa,CAACoC,MAAd,CAAqB,CAArB,EAAwB,CAAxB,EAA2B;AACzBhB,MAAAA,IAAI,EAAE,iBADmB;AAEzBiB,MAAAA,MAAM,EAAE;AAFiB,KAA3B;AAID;;AACD/B,EAAAA,IAAI,CAACgC,OAAL,CAAatC,aAAa,CAAC,CAAD,CAAb,CAAiBqC,MAA9B,EAAsCL,UAAU,CAACb,KAAX,CAAiB,GAAjB,CAAtC,EAA6D,EAA7D;AACAb,EAAAA,IAAI,CAACE,UAAL,CAAgBK,OAAO,CAACb,aAAa,CAAC,CAAD,CAAb,CAAiBqC,MAAlB,EAA0BL,UAA1B,CAAvB,EAA8DC,iBAA9D,EAdgE,CAgBhE;;AACA3B,EAAAA,IAAI,CAACgC,OAAL,CAAalC,CAAb,EAAgB4B,UAAU,CAACb,KAAX,CAAiB,GAAjB,CAAhB,EAAuCN,OAAO,CAACT,CAAD,EAAI4B,UAAJ,CAAP,IAA0B,EAAjE,EAjBgE,CAmBhE;;AACA1B,EAAAA,IAAI,CAACE,UAAL,CAAgB0B,YAAhB,EAA8BrB,OAAO,CAACT,CAAD,EAAI4B,UAAJ,CAArC,EApBgE,CAsBhE;;AACA1B,EAAAA,IAAI,CAACE,UAAL,CAAgBK,OAAO,CAACT,CAAD,EAAI4B,UAAJ,CAAvB,EAAwCE,YAAxC,EAvBgE,CAyBhE;AACA;AACA;;AACA,MAAI,CAAC5B,IAAI,CAACqB,SAAL,CAAe,wBAAf,EAAyC,KAAzC,CAAL,EAAsD;AACpD1B,IAAAA,eAAe,GAAG,IAAlB;AACD,GA9B+D,CAgChE;;;AACA,SAAOK,IAAI,CAACI,eAAL,CAAqBG,OAAO,CAACT,CAAD,EAAI4B,UAAJ,CAA5B,CAAP;AACD,CAlCD;AAoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA1B,IAAI,CAACiC,UAAL,GAAkB,UAASzB,MAAT,EAAiBC,QAAjB,EAA2BM,KAA3B,EAAkC;AAElD;AACA,MAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC;AAChCmB,IAAAA,MAAM,CAACC,cAAP,CAAsB3B,MAAtB,EAA8BC,QAA9B,EAAwC;AACtC2B,MAAAA,UAAU,EAAG;AADyB,KAAxC;AAGD,GAJD,CAKA;AALA,OAMK;AACHF,MAAAA,MAAM,CAACC,cAAP,CAAsB3B,MAAtB,EAA8BC,QAA9B,EAAwC;AACtCM,QAAAA,KAAK,EAAQA,KADyB;AAEtCqB,QAAAA,UAAU,EAAG;AAFyB,OAAxC;AAID;;AAED,SAAO5B,MAAP;AACD,CAjBD;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCAR,IAAI,CAACsB,aAAL,GAAqB,UAASd,MAAT,EAAiBC,QAAjB,EAA2BM,KAA3B,EAAkC;AACrD,MAAIsB,UAAU,GAAG,IAAjB,CADqD,CAGrD;;AACA,MAAI,OAAO5B,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAOyB,MAAM,CAACC,cAAP,CAAsB3B,MAAtB,EAA8BC,QAA9B,EAAwC;AAC7CM,MAAAA,KAAK,EAAI,OAAOA,KAAP,KAAiB,WAAlB,GAAiCP,MAAM,CAACC,QAAD,CAAvC,GAAoDM,KADf;AAE7CuB,MAAAA,QAAQ,EAAG,KAFkC;AAG7CC,MAAAA,YAAY,EAAE;AAH+B,KAAxC,CAAP;AAKD,GAVoD,CAYrD;;;AACA,MAAI5B,KAAK,CAACC,OAAN,CAAcH,QAAd,CAAJ,EAA6B;AAC3B4B,IAAAA,UAAU,GAAG5B,QAAb;AACD,GAFD,MAGK;AACH4B,IAAAA,UAAU,GAAGH,MAAM,CAACM,IAAP,CAAYhC,MAAZ,CAAb;AACD,GAlBoD,CAoBrD;;;AACA,OAAK,IAAIiC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,UAAU,CAACrB,MAA/B,EAAuCyB,CAAC,EAAxC,EAA4C;AAC1C,QAAIC,YAAY,GAAGL,UAAU,CAACI,CAAD,CAA7B;AAAA,QACI1B,KAAK,GAAGP,MAAM,CAACkC,YAAD,CADlB;;AAGA,QAAI3B,KAAK,YAAYxC,SAArB,EAAgC;AAC9B2D,MAAAA,MAAM,CAACC,cAAP,CAAsB3B,MAAtB,EAA8BkC,YAA9B,EAA4C;AAC1C3B,QAAAA,KAAK,EAAEA,KAAK,CAAC4B,OAAN,EADmC;AAE1CL,QAAAA,QAAQ,EAAE,KAFgC;AAG1CC,QAAAA,YAAY,EAAE;AAH4B,OAA5C;AAKD,KAND,MAMO,IAAI5B,KAAK,CAACC,OAAN,CAAcG,KAAd,CAAJ,EAA0B;AAC/B;AACAA,MAAAA,KAAK,CAAC6B,OAAN,CAAc,CAACC,IAAD,EAAOC,KAAP,KAAiB;AAAE,YAAI9C,IAAI,CAAC+C,QAAL,CAAcF,IAAd,KAAuBlC,KAAK,CAACC,OAAN,CAAciC,IAAd,CAA3B,EAAgD7C,IAAI,CAACsB,aAAL,CAAmBuB,IAAnB;AAA0B,OAA3G;AAEAX,MAAAA,MAAM,CAACC,cAAP,CAAsB3B,MAAtB,EAA8BkC,YAA9B,EAA4C;AAC1C3B,QAAAA,KAAK,EAAEmB,MAAM,CAACc,MAAP,CAAcjC,KAAd;AADmC,OAA5C;AAGD,KAPM,MAOA;AACLmB,MAAAA,MAAM,CAACC,cAAP,CAAsB3B,MAAtB,EAA8BkC,YAA9B,EAA4C;AAC1C3B,QAAAA,KAAK,EAAEA,KADmC;AAE1CuB,QAAAA,QAAQ,EAAG,KAF+B;AAG1CC,QAAAA,YAAY,EAAE;AAH4B,OAA5C,EADK,CAOL;;AACAL,MAAAA,MAAM,CAACe,iBAAP,CAAyBzC,MAAzB,EARK,CAUL;;AACA,UAAIR,IAAI,CAAC+C,QAAL,CAAchC,KAAd,CAAJ,EAA0B;AACxBf,QAAAA,IAAI,CAACsB,aAAL,CAAmBP,KAAnB;AACD;AACF;AACF;;AAED,SAAOP,MAAP;AACD,CAxDD;AA0DA;;;;;;;;;;;;;;;AAaAR,IAAI,CAACkD,gBAAL,GAAwB,YAAW;AACjC,MAAIpD,CAAC,GAAG,IAAR;AACA,SAAOJ,aAAa,CAACwB,KAAd,CAAoB,CAApB,CAAP;AACD,CAHD;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DAlB,IAAI,CAACG,eAAL,GAAuB,UAASgD,SAAT,EAAoB;AAEzC;AACA,MAAIrD,CAAC,GAAG,IAAR;AAAA,MACIyB,MAAM,GAAG,EADb,CAHyC,CAMzC;;AACAvC,EAAAA,QAAQ,GAAGgB,IAAI,CAACqB,SAAL,CAAe,UAAf,EAA2B,aAA3B,CAAX,CAPyC,CASzC;;AACArC,EAAAA,QAAQ,GAAGgB,IAAI,CAACqB,SAAL,CAAe,iBAAf,EAAkCrC,QAAlC,CAAX,CAVyC,CAYzC;;AACAA,EAAAA,QAAQ,GAAGA,QAAQ,CAAC6B,KAAT,CAAe,GAAf,CAAX;AAEA/B,EAAAA,UAAU,GAAGqE,SAAS,IAAInD,IAAI,CAACqB,SAAL,CAAe,iBAAf,EAAkC3C,IAAI,CAAC0E,IAAL,CAAWC,OAAO,CAACC,GAAR,EAAX,EAA0B,QAA1B,CAAlC,CAA1B;;AACA,MAAIxE,UAAU,CAACyE,OAAX,CAAmB,GAAnB,MAA4B,CAAhC,EAAmC;AACjCzE,IAAAA,UAAU,GAAGJ,IAAI,CAAC0E,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAA0BxE,UAA1B,CAAb;AACD;;AAEDG,EAAAA,YAAY,GAAGe,IAAI,CAACqB,SAAL,CAAe,mBAAf,CAAf;AACAnC,EAAAA,IAAI,GAAGc,IAAI,CAACqB,SAAL,CAAe,MAAf,CAAP;AACAlC,EAAAA,QAAQ,GAAGa,IAAI,CAACqB,SAAL,CAAe,UAAf,CAAX;AACAhC,EAAAA,oBAAoB,GAAGW,IAAI,CAACqB,SAAL,CAAe,sBAAf,CAAvB,CAvByC,CAyBzC;;AACAtC,EAAAA,qBAAqB,GAAGiB,IAAI,CAACqB,SAAL,CAAe,0BAAf,EAA2C3C,IAAI,CAAC0E,IAAL,CAAUtE,UAAV,EAAuB,cAAvB,CAA3C,CAAxB;AAEAQ,EAAAA,kBAAkB,GAAGU,IAAI,CAACqB,SAAL,CAAe,oBAAf,CAArB;;AACA,MAAI/B,kBAAJ,EAAwB;AACtB,QAAI;AACF,UAAIkE,YAAY,GAAG9E,IAAI,CAAC+E,UAAL,CAAgBnE,kBAAhB,IACfA,kBADe,GAEfZ,IAAI,CAAC0E,IAAL,CAAUtE,UAAV,EAAsBQ,kBAAtB,CAFJ;AAGAd,MAAAA,MAAM,GAAGH,OAAO,CAACmF,YAAD,CAAhB;AACD,KALD,CAMA,OAAOE,CAAP,EAAU;AACRC,MAAAA,OAAO,CAACC,IAAR,CAAa,uCAAuCtE,kBAApD;AACAqE,MAAAA,OAAO,CAACE,GAAR,CAAYH,CAAZ;AACD;AACF,GAxCwC,CA0CzC;AACA;;;AACA,MAAI;AACF,QAAII,QAAQ,GAAG5E,IAAI,IAAIC,QAAvB;;AAEA,QAAI,CAAC2E,QAAL,EAAe;AACX,UAAIC,EAAE,GAAG1F,OAAO,CAAC,IAAD,CAAhB;;AACAyF,MAAAA,QAAQ,GAAGC,EAAE,CAACC,QAAH,EAAX;AACH;AACF,GAPD,CAOE,OAAON,CAAP,EAAU;AACVI,IAAAA,QAAQ,GAAG,EAAX;AACD,GArDwC,CAuDzC;;;AACAvE,EAAAA,GAAG,CAACJ,QAAJ,GAAe2E,QAAf,CAxDyC,CA0DzC;;AACA,MAAIG,SAAS,GAAG,CAAC,SAAD,EAAYC,MAAZ,CAAmBlF,QAAnB,CAAhB,CA3DyC,CA6DzC;;AACA,MAAI8E,QAAJ,EAAc;AACZ,QAAIK,WAAW,GAAGL,QAAQ,CAACjD,KAAT,CAAe,GAAf,EAAoB,CAApB,CAAlB;AAEA7B,IAAAA,QAAQ,CAAC4D,OAAT,CAAiB,UAASrD,GAAT,EAAc;AAC7B;AACA0E,MAAAA,SAAS,CAACG,IAAV,CAAeD,WAAf,EAA4BA,WAAW,GAAG,GAAd,GAAoB5E,GAAhD,EAF6B,CAI7B;;AACA,UAAIuE,QAAQ,KAAKK,WAAjB,EAA8B;AAC5BF,QAAAA,SAAS,CAACG,IAAV,CAAeN,QAAf,EAAyBA,QAAQ,GAAG,GAAX,GAAiBvE,GAA1C;AACD;AACF,KARD;AASD;;AAEDP,EAAAA,QAAQ,CAAC4D,OAAT,CAAiB,UAASrD,GAAT,EAAc;AAC7B0E,IAAAA,SAAS,CAACG,IAAV,CAAe,OAAf,EAAwB,WAAW7E,GAAnC;AACD,GAFD;AAIA,MAAI8E,YAAY,GAAG,EAAnB;AACA,MAAIC,eAAe,GAAG,CAAtB;AACA,MAAIC,QAAQ,GAAG/F,MAAM,CAACgG,aAAP,EAAf;AACAP,EAAAA,SAAS,CAACrB,OAAV,CAAkB,UAAS6B,QAAT,EAAmB;AACnCF,IAAAA,QAAQ,CAAC3B,OAAT,CAAiB,UAAS8B,OAAT,EAAkB;AACjCL,MAAAA,YAAY,CAACI,QAAQ,GAAG,GAAX,GAAiBC,OAAlB,CAAZ,GAAyCJ,eAAe,EAAxD;;AACA,UAAIrF,YAAJ,EAAkB;AAChBoF,QAAAA,YAAY,CAACI,QAAQ,GAAG,GAAX,GAAiBxF,YAAjB,GAAgC,GAAhC,GAAsCyF,OAAvC,CAAZ,GAA8DJ,eAAe,EAA7E;AACD;AACF,KALD;AAMD,GAPD;AASA,MAAIK,YAAY,GAAG3E,IAAI,CAAC4E,mBAAL,CAAyB9F,UAAzB,EAAqCuF,YAArC,CAAnB;AACAM,EAAAA,YAAY,CAAC/B,OAAb,CAAqB,UAASiC,YAAT,EAAuB;AAC1C,QAAIC,SAAS,GAAG9E,IAAI,CAAC+E,SAAL,CAAeF,YAAf,CAAhB;;AACA,QAAIC,SAAJ,EAAe;AACb9E,MAAAA,IAAI,CAACE,UAAL,CAAgBqB,MAAhB,EAAwBuD,SAAxB;AACD;AACF,GALD,EA7FyC,CAoGzC;AACA;;AACA,MAAI,CAAC3B,SAAL,EAAgB;AACd,QAAI6B,SAAS,GAAG,EAAhB;;AACA,QAAI3B,OAAO,CAAC9D,GAAR,CAAYV,WAAhB,EAA6B;AAC3B,UAAI;AACFmG,QAAAA,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAW7B,OAAO,CAAC9D,GAAR,CAAYV,WAAvB,CAAZ;AACD,OAFD,CAEE,OAAM6E,CAAN,EAAS;AACTC,QAAAA,OAAO,CAACwB,KAAR,CAAc,yDAAd;AACD;;AACDnF,MAAAA,IAAI,CAACE,UAAL,CAAgBqB,MAAhB,EAAwByD,SAAxB;AACAtF,MAAAA,aAAa,CAAC0E,IAAd,CAAmB;AACjBtD,QAAAA,IAAI,EAAE,cADW;AAEjBiB,QAAAA,MAAM,EAAEiD;AAFS,OAAnB;AAID,KAba,CAed;;;AACA,QAAII,aAAa,GAAGpF,IAAI,CAACqF,aAAL,CAAmB,aAAnB,CAApB;;AACA,QAAID,aAAJ,EAAmB;AACjB,UAAI;AACFA,QAAAA,aAAa,GAAGH,IAAI,CAACC,KAAL,CAAWE,aAAX,CAAhB;AACD,OAFD,CAEE,OAAM1B,CAAN,EAAS;AACTC,QAAAA,OAAO,CAACwB,KAAR,CAAc,kEAAd;AACD;;AACDnF,MAAAA,IAAI,CAACE,UAAL,CAAgBqB,MAAhB,EAAwB6D,aAAxB;AACA1F,MAAAA,aAAa,CAAC0E,IAAd,CAAmB;AACjBtD,QAAAA,IAAI,EAAE,wBADW;AAEjBiB,QAAAA,MAAM,EAAEqD;AAFS,OAAnB;AAID,KA5Ba,CA8Bd;;;AACA7F,IAAAA,GAAG,CAAC,aAAD,CAAH,GAAqB0F,IAAI,CAACK,SAAL,CAAetF,IAAI,CAACE,UAAL,CAAgB8E,SAAhB,EAA2BI,aAA3B,EAA0C,EAA1C,CAAf,CAArB;AACD,GAtIwC,CAwIzC;;;AACA,MAAIG,aAAa,GAAGvF,IAAI,CAACwF,gBAAL,CAAsB1G,UAAtB,EAAkCyF,QAAlC,CAApB;AACAvE,EAAAA,IAAI,CAACE,UAAL,CAAgBqB,MAAhB,EAAwBgE,aAAxB,EA1IyC,CA4IzC;;AACA,MAAIE,WAAW,GAAGzF,IAAI,CAAC+E,SAAL,CAAehG,qBAAf,KAAyC,EAA3D;AACAiB,EAAAA,IAAI,CAACE,UAAL,CAAgBqB,MAAhB,EAAwBkE,WAAxB;AAEAzF,EAAAA,IAAI,CAAC0F,sBAAL,CAA4BnE,MAA5B,EAhJyC,CAkJzC;;AACA,SAAOA,MAAP;AACD,CApJD;AAsJA;;;;;;;;;;;;;AAWAvB,IAAI,CAAC4E,mBAAL,GAA2B,UAASe,UAAT,EAAqBtB,YAArB,EAAmC;AAC5D,SAAOsB,UAAU,CAAC9E,KAAX,CAAiBnC,IAAI,CAACkH,SAAtB,EACJC,MADI,CACG,UAASC,KAAT,EAAgB3C,SAAhB,EAA2B;AACjC,QAAIA,SAAJ,EAAe;AACb,UAAI;AACFxE,QAAAA,UAAU,CAACoH,WAAX,CAAuB5C,SAAvB,EAAkCP,OAAlC,CAA0C,UAASoD,IAAT,EAAe;AACvD,cAAI3B,YAAY,CAAC2B,IAAD,CAAhB,EAAwB;AACtBF,YAAAA,KAAK,CAAC1B,IAAN,CAAW,CAACC,YAAY,CAAC2B,IAAD,CAAb,EAAqBtH,IAAI,CAAC0E,IAAL,CAAUD,SAAV,EAAqB6C,IAArB,CAArB,CAAX;AACD;AACF,SAJD;AAKD,OAND,CAOA,OAAMtC,CAAN,EAAS,CAAE;;AACX,aAAOoC,KAAP;AACD;AACF,GAbI,EAaF,EAbE,EAcJG,IAdI,CAcC,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAAE,WAAOD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAf;AAAqB,GAdvC,EAeJC,GAfI,CAeA,UAASJ,IAAT,EAAe;AAAE,WAAOA,IAAI,CAAC,CAAD,CAAX;AAAiB,GAflC,CAAP;AAgBD,CAjBD,C,CAmBA;;;AACAhG,IAAI,CAAC0F,sBAAL,GAA8B,UAAUnE,MAAV,EAAkB;AAC9C,MAAI8E,QAAQ,GAAG,EAAf;;AAEA,WAASC,QAAT,CAAmBC,IAAnB,EAAyB;AAEvB;AACA,QAAIC,WAAW,GAAG,EAAlB,CAHuB,CAKvB;;AACA,SAAK,IAAI/F,QAAT,IAAqB8F,IAArB,EAA2B;AACzB,UAAIA,IAAI,CAACE,cAAL,CAAoBhG,QAApB,KAAiC8F,IAAI,CAAC9F,QAAD,CAAJ,IAAkB,IAAvD,EAA6D;AAC3D+F,QAAAA,WAAW,CAACpC,IAAZ,CAAiB3D,QAAjB;AACD;AACF,KAVsB,CAYvB;;;AACA+F,IAAAA,WAAW,CAACP,IAAZ,GAAmBrD,OAAnB,CAA2B,UAAUnC,QAAV,EAAoB;AAC7C,UAAI8F,IAAI,CAAC9F,QAAD,CAAJ,CAAeiG,WAAf,KAA+BxE,MAAnC,EAA2C;AACzCoE,QAAAA,QAAQ,CAACC,IAAI,CAAC9F,QAAD,CAAL,CAAR;AACD,OAFD,MAEO,IAAI8F,IAAI,CAAC9F,QAAD,CAAJ,CAAeiG,WAAf,KAA+B/F,KAAnC,EAA0C;AAC/C,aAAK,IAAI8B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8D,IAAI,CAAC9F,QAAD,CAAJ,CAAeO,MAAnC,EAA2CyB,CAAC,EAA5C,EAAgD;AAC9C,cAAI8D,IAAI,CAAC9F,QAAD,CAAJ,CAAegC,CAAf,aAA6BnE,cAAjC,EAAiD;AAC/C+H,YAAAA,QAAQ,CAACjC,IAAT,CAAcmC,IAAI,CAAC9F,QAAD,CAAJ,CAAegC,CAAf,EAAkBkE,OAAlB,CAA0BpF,MAA1B,EAAkCgF,IAAI,CAAC9F,QAAD,CAAtC,EAAkDgC,CAAlD,CAAd;AACD,WAFD,MAGK;AACH6D,YAAAA,QAAQ,CAACC,IAAI,CAAC9F,QAAD,CAAJ,CAAegC,CAAf,CAAD,CAAR;AACD;AACF;AACF,OATM,MASA;AACL,YAAI8D,IAAI,CAAC9F,QAAD,CAAJ,YAA0BnC,cAA9B,EAA8C;AAC5C+H,UAAAA,QAAQ,CAACjC,IAAT,CAAcmC,IAAI,CAAC9F,QAAD,CAAJ,CAAekG,OAAf,CAAuBpF,MAAvB,EAA+BgF,IAA/B,EAAqC9F,QAArC,CAAd;AACD,SAHI,CAIL;;AACD;AACF,KAlBD;AAmBD;;AAED6F,EAAAA,QAAQ,CAAC/E,MAAD,CAAR;;AAEA8E,EAAAA,QAAQ,CAACzD,OAAT,CAAiB,UAAUgE,KAAV,EAAiB;AAAEA,IAAAA,KAAK,CAACjE,OAAN;AAAkB,GAAtD;AACD,CAxCD;AA0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA3C,IAAI,CAAC+E,SAAL,GAAiB,UAASF,YAAT,EAAuB;AACtC,MAAI/E,CAAC,GAAG,IAAR;AAAA,MAAe;AACX+G,EAAAA,YAAY,GAAG,IADnB;AAAA,MAEIC,WAAW,GAAG,IAFlB;AAAA,MAGIC,IAAI,GAAG,IAHX,CADsC,CAMtC;AACA;;AAEA,MAAI;AACF;AACAD,IAAAA,WAAW,GAAGnI,UAAU,CAACqI,YAAX,CAAwBnC,YAAxB,EAAsC,OAAtC,CAAd;AACAiC,IAAAA,WAAW,GAAGA,WAAW,CAACG,OAAZ,CAAoB,SAApB,EAA+B,EAA/B,CAAd;AACD,GAJD,CAKA,OAAOC,EAAP,EAAW;AACT,QAAIA,EAAE,CAACC,IAAH,KAAY,QAAhB,EAA0B;AACxB,YAAM,IAAI/F,KAAJ,CAAU,iBAAiByD,YAAjB,GAAgC,kCAAhC,GAAmEqC,EAAE,CAACC,IAAtE,GACG,sBADH,GAC0BD,EAAE,CAACE,OADvC,CAAN;AAED;;AACD,WAAO,IAAP,CALS,CAKK;AACf,GApBqC,CAsBtC;;;AACA,MAAI;AAEF;AACA,QAAI/H,oBAAJ,EAA0B;AACxB,UAAIO,iBAAiB,CAACyH,IAAlB,CAAuBP,WAAvB,CAAJ,EAAyC;AACvCnD,QAAAA,OAAO,CAACwB,KAAR,CAAc,cAAcN,YAAd,GAA6B,iEAA3C;AACA,eAAO,IAAP;AACD;AACF;;AAEDgC,IAAAA,YAAY,GAAGrI,MAAM,CAAC0G,KAAP,CAAaL,YAAb,EAA2BiC,WAA3B,CAAf;AACD,GAXD,CAYA,OAAOQ,EAAP,EAAW;AACT,QAAI1H,iBAAiB,CAACyH,IAAlB,CAAuBP,WAAvB,CAAJ,EAAyC;AACvCnD,MAAAA,OAAO,CAACwB,KAAR,CAAc,YAAYN,YAAZ,GAA2B,2DAAzC;AACD;;AACD,UAAM,IAAIzD,KAAJ,CAAU,gCAAgCyD,YAAhC,GAA+C,KAA/C,GAAuDyC,EAAjE,CAAN;AACD,GAxCqC,CA0CtC;;;AACA,MAAI,OAAOT,YAAP,KAAwB,QAA5B,EAAsC;AACpCnH,IAAAA,aAAa,CAAC0E,IAAd,CAAmB;AACjBtD,MAAAA,IAAI,EAAE+D,YADW;AAEjB0C,MAAAA,QAAQ,EAAET,WAFO;AAGjB/E,MAAAA,MAAM,EAAE8E;AAHS,KAAnB;AAKD;;AAED,SAAOA,YAAP;AACD,CApDD;AAsDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA7G,IAAI,CAACwH,WAAL,GAAmB,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,MAAIC,MAAM,GAAGnJ,MAAM,CAACoJ,SAAP,CAAiBF,MAAjB,CAAb;;AACA,MAAI,OAAOC,MAAP,KAAkB,UAAtB,EAAkC;AAChC,WAAOA,MAAM,CAAC,IAAD,EAAOF,OAAP,CAAb;AACD;AACF,CALD;AAOA;;;;;;;;;;;;;;;;;;;;;AAmBAzH,IAAI,CAACI,eAAL,GAAuB,UAASyH,QAAT,EAAmBC,KAAnB,EAA0B;AAC/C,MAAID,QAAQ,YAAYtJ,SAAxB,EAAmC;AACjC,WAAOsJ,QAAP;AACD,GAH8C,CAK/C;;;AACA,MAAI/H,CAAC,GAAG,IAAR;AACAgI,EAAAA,KAAK,GAAIA,KAAK,KAAK,IAAV,GAAiBlJ,mBAAjB,GAAuCkJ,KAAhD;;AACA,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACb,WAAOD,QAAP;AACD,GAV8C,CAY/C;AACA;;;AACA,OAAK,IAAI9H,MAAT,IAAmBF,MAAM,CAACS,SAA1B,EAAqC;AACnC,QAAI,CAACuH,QAAQ,CAAC9H,MAAD,CAAb,EAAuB;AACrBC,MAAAA,IAAI,CAACiC,UAAL,CAAgB4F,QAAhB,EAA0B9H,MAA1B,EAAkCF,MAAM,CAACS,SAAP,CAAiBP,MAAjB,CAAlC;AACD;AACF,GAlB8C,CAoB/C;;;AACA,OAAK,IAAIwG,IAAT,IAAiBsB,QAAjB,EAA2B;AACzB,QAAI7H,IAAI,CAAC+C,QAAL,CAAc8E,QAAQ,CAACtB,IAAD,CAAtB,CAAJ,EAAmC;AACjCvG,MAAAA,IAAI,CAACI,eAAL,CAAqByH,QAAQ,CAACtB,IAAD,CAA7B,EAAqCuB,KAAK,GAAG,CAA7C;AACD;AACF,GAzB8C,CA2B/C;;;AACA,SAAOD,QAAP;AACD,CA7BD;AA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA7H,IAAI,CAAC6B,SAAL,GAAiB,SAASA,SAAT,CAAmBkG,MAAnB,EAA2BD,KAA3B,EAAkCE,QAAlC,EAA4C1H,SAA5C,EAAuD;AACtE;AACA;AACA,MAAI2H,UAAU,GAAG,EAAjB;AACA,MAAIC,WAAW,GAAG,EAAlB;AAEA,MAAIC,SAAS,GAAG,OAAOC,MAAP,IAAiB,WAAjC;AAEA,MAAI,OAAOJ,QAAP,KAAoB,WAAxB,EACEA,QAAQ,GAAG,IAAX;AAEF,MAAI,OAAOF,KAAP,KAAiB,WAArB,EACEA,KAAK,GAAG,EAAR,CAZoE,CActE;;AACA,WAASO,MAAT,CAAgBN,MAAhB,EAAwBD,KAAxB,EAA+B;AAC7B;AACA,QAAIC,MAAM,KAAK,IAAf,EACE,OAAO,IAAP;AAEF,QAAID,KAAK,KAAK,CAAd,EACE,OAAOC,MAAP;AAEF,QAAIO,KAAJ;;AACA,QAAI,OAAOP,MAAP,IAAiB,QAArB,EAA+B;AAC7B,aAAOA,MAAP;AACD;;AAED,QAAItJ,KAAK,CAACmC,OAAN,CAAcmH,MAAd,CAAJ,EAA2B;AACzBO,MAAAA,KAAK,GAAG,EAAR;AACD,KAFD,MAEO,IAAI7J,KAAK,CAAC8J,QAAN,CAAeR,MAAf,CAAJ,EAA4B;AACjCO,MAAAA,KAAK,GAAG,IAAIE,MAAJ,CAAWT,MAAM,CAACU,MAAlB,EAA0BzI,IAAI,CAAC0I,cAAL,CAAoBX,MAApB,CAA1B,CAAR;AACA,UAAIA,MAAM,CAACY,SAAX,EAAsBL,KAAK,CAACK,SAAN,GAAkBZ,MAAM,CAACY,SAAzB;AACvB,KAHM,MAGA,IAAIlK,KAAK,CAACmK,MAAN,CAAab,MAAb,CAAJ,EAA0B;AAC/BO,MAAAA,KAAK,GAAG,IAAIO,IAAJ,CAASd,MAAM,CAACe,OAAP,EAAT,CAAR;AACD,KAFM,MAEA,IAAIX,SAAS,IAAIC,MAAM,CAACW,QAAP,CAAgBhB,MAAhB,CAAjB,EAA0C;AAC/CO,MAAAA,KAAK,GAAG,IAAIF,MAAJ,CAAWL,MAAM,CAAC/G,MAAlB,CAAR;AACA+G,MAAAA,MAAM,CAACiB,IAAP,CAAYV,KAAZ;AACA,aAAOA,KAAP;AACD,KAJM,MAIA;AACL,UAAI,OAAOhI,SAAP,KAAqB,WAAzB,EAAsCgI,KAAK,GAAGpG,MAAM,CAAC+G,MAAP,CAAc/G,MAAM,CAACgH,cAAP,CAAsBnB,MAAtB,CAAd,CAAR,CAAtC,KACKO,KAAK,GAAGpG,MAAM,CAAC+G,MAAP,CAAc3I,SAAd,CAAR;AACN;;AAED,QAAI0H,QAAJ,EAAc;AACZ,UAAIlF,KAAK,GAAGmF,UAAU,CAAC1E,OAAX,CAAmBwE,MAAnB,CAAZ;;AAEA,UAAIjF,KAAK,IAAI,CAAC,CAAd,EAAiB;AACf,eAAOoF,WAAW,CAACpF,KAAD,CAAlB;AACD;;AACDmF,MAAAA,UAAU,CAAC7D,IAAX,CAAgB2D,MAAhB;AACAG,MAAAA,WAAW,CAAC9D,IAAZ,CAAiBkE,KAAjB;AACD;;AAED,SAAK,IAAI7F,CAAT,IAAcsF,MAAd,EAAsB;AACpB,UAAIoB,cAAc,GAAIjH,MAAM,CAACkH,wBAAP,CAAgCrB,MAAhC,EAAuCtF,CAAvC,CAAtB;AACA,UAAI4G,SAAS,GAAKF,cAAc,KAAKlI,SAApB,IAAmCkI,cAAc,CAAChI,GAAf,KAAuBF,SAA3E;;AAEA,UAAIoI,SAAJ,EAAc;AACZnH,QAAAA,MAAM,CAACC,cAAP,CAAsBmG,KAAtB,EAA4B7F,CAA5B,EAA8B0G,cAA9B;AACD,OAFD,MAEO,IAAInJ,IAAI,CAACsJ,SAAL,CAAevB,MAAM,CAACtF,CAAD,CAArB,CAAJ,EAA+B;AACpC6F,QAAAA,KAAK,CAAC7F,CAAD,CAAL,GAAWsF,MAAM,CAACtF,CAAD,CAAjB;AACD,OAFM,MAEA;AACL6F,QAAAA,KAAK,CAAC7F,CAAD,CAAL,GAAW4F,MAAM,CAACN,MAAM,CAACtF,CAAD,CAAP,EAAYqF,KAAK,GAAG,CAApB,CAAjB;AACD;AACF;;AAED,WAAOQ,KAAP;AACD;;AAED,SAAOD,MAAM,CAACN,MAAD,EAASD,KAAT,CAAb;AACD,CAvED;AAyEA;;;;;;;;;;;AASA9H,IAAI,CAACgC,OAAL,GAAe,UAAUxB,MAAV,EAAkB+I,IAAlB,EAAwBxI,KAAxB,EAA+B;AAC5C,MAAIyI,OAAO,GAAG,IAAd;;AACA,MAAIzI,KAAK,KAAK,IAAV,IAAkBwI,IAAI,CAACvI,MAAL,KAAgB,CAAtC,EAAyC;AACvC;AACD,GAFD,MAGK,IAAIuI,IAAI,CAACvI,MAAL,KAAgB,CAApB,EAAuB;AAAE;AAC5BR,IAAAA,MAAM,CAAC+I,IAAI,CAACE,KAAL,EAAD,CAAN,GAAuB1I,KAAvB;AACD,GAFI,MAGA;AACHyI,IAAAA,OAAO,GAAGD,IAAI,CAACE,KAAL,EAAV;;AACA,QAAI,CAACjJ,MAAM,CAACiG,cAAP,CAAsB+C,OAAtB,CAAL,EAAqC;AACnChJ,MAAAA,MAAM,CAACgJ,OAAD,CAAN,GAAkB,EAAlB;AACD;;AACDxJ,IAAAA,IAAI,CAACgC,OAAL,CAAaxB,MAAM,CAACgJ,OAAD,CAAnB,EAA8BD,IAA9B,EAAoCxI,KAApC;AACD;AACF,CAfD;AAiBA;;;;;;;;;;;;;;;;AAcAf,IAAI,CAAC0J,cAAL,GAAsB,UAAUC,eAAV,EAA2BC,SAA3B,EAAsC;AAC1D,MAAIC,MAAM,GAAG,EAAb;;AAEA,WAASC,eAAT,CAAyB1D,GAAzB,EAA8B2D,IAA9B,EAAoCC,MAApC,EAA4C;AAC1C,SAAK,IAAIzD,IAAT,IAAiBH,GAAjB,EAAsB;AACpB,UAAIrF,KAAK,GAAGqF,GAAG,CAACG,IAAD,CAAf;;AACA,UAAI,OAAOxF,KAAP,KAAkB,QAAtB,EAAgC;AAAE;AAChC,YAAIgJ,IAAI,CAAChJ,KAAD,CAAR,EAAiB;AAAE;AACjBf,UAAAA,IAAI,CAACgC,OAAL,CAAa6H,MAAb,EAAqBG,MAAM,CAAC9F,MAAP,CAAcqC,IAAd,CAArB,EAA0CwD,IAAI,CAAChJ,KAAD,CAA9C;AACD;AACF,OAJD,MAKK,IAAIf,IAAI,CAAC+C,QAAL,CAAchC,KAAd,CAAJ,EAA0B;AAAE;AAC/B,YAAG,YAAYA,KAAZ,IAAqB,cAAcA,KAAnC,IAA4CgJ,IAAI,CAAChJ,KAAK,CAACkJ,MAAP,CAAnD,EAAmE;AACjE,cAAI;AACF,gBAAIC,WAAW,GAAGlK,IAAI,CAACwH,WAAL,CAAiBuC,IAAI,CAAChJ,KAAK,CAACkJ,MAAP,CAArB,EAAqClJ,KAAK,CAACoJ,QAA3C,CAAlB;AACD,WAFD,CAEE,OAAMC,GAAN,EAAW;AACXA,YAAAA,GAAG,CAAChD,OAAJ,GAAc,8BAA8BrG,KAAK,CAACkJ,MAApC,GAA6C,IAA7C,GAAoDG,GAAG,CAAChD,OAAtE;AACA,kBAAMgD,GAAN;AACD;;AACDpK,UAAAA,IAAI,CAACgC,OAAL,CAAa6H,MAAb,EAAqBG,MAAM,CAAC9F,MAAP,CAAcqC,IAAd,CAArB,EAA0C2D,WAA1C;AACD,SARD,MAQO;AACLJ,UAAAA,eAAe,CAAC/I,KAAD,EAAQgJ,IAAR,EAAcC,MAAM,CAAC9F,MAAP,CAAcqC,IAAd,CAAd,CAAf;AACD;AACF,OAZI,MAaA;AACH8D,QAAAA,GAAG,GAAG,8CAA8CL,MAAM,CAAC5G,IAAP,CAAY,GAAZ,CAA9C,GAAiE,IAAjE,GAAwE,OAAOrC,KAArF;AACA,cAAMK,KAAK,CAACiJ,GAAD,CAAX;AACD;AACF;AACF;;AAEDP,EAAAA,eAAe,CAACH,eAAD,EAAkBC,SAAlB,EAA6B,EAA7B,CAAf;;AACA,SAAOC,MAAP;AAED,CAlCD;AAoCA;;;;;;;;;;;AASA7J,IAAI,CAACwF,gBAAL,GAAwB,UAAU1G,UAAV,EAAsByF,QAAtB,EAAgC;AACtD,MAAIsF,MAAM,GAAG,EAAb;AACAtF,EAAAA,QAAQ,CAAC3B,OAAT,CAAiB,UAAU8B,OAAV,EAAmB;AAClC,QAAIG,YAAY,GAAGnG,IAAI,CAAC0E,IAAL,CAAUtE,UAAV,EAAuB,iCAAiC,GAAjC,GAAuC4F,OAA9D,CAAnB;AACA,QAAII,SAAS,GAAG9E,IAAI,CAAC+E,SAAL,CAAeF,YAAf,CAAhB;;AACA,QAAIC,SAAJ,EAAe;AACb,UAAIwF,wBAAwB,GAAGtK,IAAI,CAAC0J,cAAL,CAAoB5E,SAApB,EAA+BzB,OAAO,CAAC9D,GAAvC,CAA/B;AACAS,MAAAA,IAAI,CAACE,UAAL,CAAgB2J,MAAhB,EAAwBS,wBAAxB;AACD;AACF,GAPD;AAQA,SAAOT,MAAP;AACD,CAXD;AAaA;;;;;;;;;;;;AAUA7J,IAAI,CAACuK,UAAL,GAAkB,UAASC,OAAT,EAAkBC,OAAlB,EAA2B3C,KAA3B,EAAkC;AAElD;AACA,MAAIhI,CAAC,GAAG,IAAR;AACAgI,EAAAA,KAAK,GAAIA,KAAK,KAAK,IAAV,GAAiBlJ,mBAAjB,GAAuCkJ,KAAhD;;AACA,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACb,WAAO,EAAP;AACD,GAPiD,CASlD;;;AACA,MAAI,CAAC0C,OAAD,IAAY,CAACC,OAAjB,EAA0B;AACxB,WAAO,KAAP;AACD;;AACD,MAAID,OAAO,KAAKC,OAAhB,EAAyB;AACvB,WAAO,IAAP;AACD;;AACD,MAAI,OAAOD,OAAP,IAAmB,QAAnB,IAA+B,OAAOC,OAAP,IAAmB,QAAtD,EAAgE;AAC9D,WAAO,KAAP;AACD,GAlBiD,CAoBlD;AACA;AACA;;;AACA,MAAIvI,MAAM,CAACM,IAAP,CAAYgI,OAAZ,EAAqBxJ,MAArB,IAA+BkB,MAAM,CAACM,IAAP,CAAYiI,OAAZ,EAAqBzJ,MAAxD,EAAgE;AAC9D,WAAO,KAAP;AACD,GAzBiD,CA2BlD;;;AACA,OAAK,IAAIuF,IAAT,IAAiBiE,OAAjB,EAA0B;AAExB;AACA,QAAIA,OAAO,CAACjE,IAAD,CAAP,IAAiB,OAAOiE,OAAO,CAACjE,IAAD,CAAd,KAA0B,QAA/C,EAAyD;AACvD,UAAI,CAACvG,IAAI,CAACuK,UAAL,CAAgBC,OAAO,CAACjE,IAAD,CAAvB,EAA+BkE,OAAO,CAAClE,IAAD,CAAtC,EAA8CuB,KAAK,GAAG,CAAtD,CAAL,EAA+D;AAC7D,eAAO,KAAP;AACD;AACF,KAJD,MAKK;AACH,UAAI0C,OAAO,CAACjE,IAAD,CAAP,KAAkBkE,OAAO,CAAClE,IAAD,CAA7B,EAAqC;AACnC,eAAO,KAAP;AACD;AACF;AACF,GAzCiD,CA2ClD;;;AACA,SAAO,IAAP;AACD,CA7CD;AA+CA;;;;;;;;;;;;;;;;;;;;;;AAoBAvG,IAAI,CAAC0K,QAAL,GAAgB,UAASF,OAAT,EAAkBC,OAAlB,EAA2B3C,KAA3B,EAAkC;AAEhD;AACA,MAAIhI,CAAC,GAAG,IAAR;AAAA,MAAc6K,IAAI,GAAG,EAArB;AACA7C,EAAAA,KAAK,GAAIA,KAAK,KAAK,IAAV,GAAiBlJ,mBAAjB,GAAuCkJ,KAAhD;;AACA,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACb,WAAO,EAAP;AACD,GAP+C,CAShD;AACA;;;AACA,OAAK,IAAI8C,IAAT,IAAiBH,OAAjB,EAA0B;AACxB,QAAII,MAAM,GAAGL,OAAO,CAACI,IAAD,CAApB;AACA,QAAIE,MAAM,GAAGL,OAAO,CAACG,IAAD,CAApB;;AACA,QAAIC,MAAM,IAAIC,MAAV,IAAoB9K,IAAI,CAAC+C,QAAL,CAAc+H,MAAd,CAAxB,EAA+C;AAC7C,UAAI,CAAE9K,IAAI,CAACuK,UAAL,CAAgBM,MAAhB,EAAwBC,MAAxB,CAAN,EAAwC;AACtCH,QAAAA,IAAI,CAACC,IAAD,CAAJ,GAAa5K,IAAI,CAAC0K,QAAL,CAAcG,MAAd,EAAsBC,MAAtB,EAA8BhD,KAAK,GAAG,CAAtC,CAAb;AACD;AACF,KAJD,MAKK,IAAInH,KAAK,CAACC,OAAN,CAAciK,MAAd,KAAyBlK,KAAK,CAACC,OAAN,CAAckK,MAAd,CAA7B,EAAoD;AACvD,UAAG,CAAC9K,IAAI,CAACuK,UAAL,CAAgBM,MAAhB,EAAwBC,MAAxB,CAAJ,EAAqC;AACnCH,QAAAA,IAAI,CAACC,IAAD,CAAJ,GAAaE,MAAb;AACD;AACF,KAJI,MAKA,IAAID,MAAM,KAAKC,MAAf,EAAsB;AACzBH,MAAAA,IAAI,CAACC,IAAD,CAAJ,GAAaE,MAAb;AACD;AACF,GA3B+C,CA6BhD;;;AACA,SAAOH,IAAP;AAED,CAhCD;AAkCA;;;;;;;;;;;;;;;AAaA3K,IAAI,CAACE,UAAL,GAAkB,UAAS6K,SAAT,EAAoB;AAEpC;AACA,MAAIjL,CAAC,GAAG,IAAR;AACA,MAAIkL,KAAK,GAAGrK,KAAK,CAACL,SAAN,CAAgBY,KAAhB,CAAsB+J,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAZ;AACA,MAAIpD,KAAK,GAAGkD,KAAK,CAACG,GAAN,EAAZ;;AACA,MAAI,OAAOrD,KAAP,IAAiB,QAArB,EAA+B;AAC7BkD,IAAAA,KAAK,CAAC5G,IAAN,CAAW0D,KAAX;AACAA,IAAAA,KAAK,GAAGlJ,mBAAR;AACD,GATmC,CAWpC;;;AACA,MAAIkJ,KAAK,GAAG,CAAZ,EAAe;AACb,WAAOiD,SAAP;AACD,GAdmC,CAgBpC;;;AACAC,EAAAA,KAAK,CAACpI,OAAN,CAAc,UAASwI,SAAT,EAAoB;AAEhC;AACA,SAAK,IAAI7E,IAAT,IAAiB6E,SAAjB,EAA4B;AAE1B;AACA,UAAIC,kBAAkB,GAAGD,SAAS,CAAC7E,IAAD,CAAT,YAA2BjI,cAApD;AACA,UAAIgN,cAAc,GAAGP,SAAS,CAACxE,IAAD,CAAT,YAA2BjI,cAAhD;;AAEA,UAAI+M,kBAAkB,IAAIN,SAAS,CAACtE,cAAV,CAAyBF,IAAzB,CAA1B,EAA0D;AACxD6E,QAAAA,SAAS,CAAC7E,IAAD,CAAT,CAAgBgF,SAAhB,GAA4BD,cAAc,GAAGP,SAAS,CAACxE,IAAD,CAAT,CAAgBgF,SAAnB,GAA+BR,SAAS,CAACxE,IAAD,CAAlF;AACD,OARyB,CAS1B;;;AACA,UAAI6E,SAAS,CAAC7E,IAAD,CAAT,YAA2BsC,IAA/B,EAAqC;AACnCkC,QAAAA,SAAS,CAACxE,IAAD,CAAT,GAAkB6E,SAAS,CAAC7E,IAAD,CAA3B;AACD;;AAAC,UAAI6E,SAAS,CAAC7E,IAAD,CAAT,YAA2BiC,MAA/B,EAAuC;AACvCuC,QAAAA,SAAS,CAACxE,IAAD,CAAT,GAAkB6E,SAAS,CAAC7E,IAAD,CAA3B;AACD,OAFC,MAEK,IAAIvG,IAAI,CAAC+C,QAAL,CAAcgI,SAAS,CAACxE,IAAD,CAAvB,KAAkCvG,IAAI,CAAC+C,QAAL,CAAcqI,SAAS,CAAC7E,IAAD,CAAvB,CAAlC,IAAoE,CAAC+E,cAAzE,EAAyF;AAC9FtL,QAAAA,IAAI,CAACE,UAAL,CAAgB6K,SAAS,CAACxE,IAAD,CAAzB,EAAiC6E,SAAS,CAAC7E,IAAD,CAA1C,EAAkDuB,KAAK,GAAG,CAA1D;AACD,OAFM,MAGF,IAAI9H,IAAI,CAACsJ,SAAL,CAAe8B,SAAS,CAAC7E,IAAD,CAAxB,CAAJ,EAAqC;AACxCwE,QAAAA,SAAS,CAACxE,IAAD,CAAT,GAAkB6E,SAAS,CAAC7E,IAAD,CAA3B;AACD,OAFI,CAGL;AAHK,WAIA,IAAI6E,SAAS,CAAC7E,IAAD,CAAT,IAAmB,OAAO6E,SAAS,CAAC7E,IAAD,CAAhB,KAA2B,QAAlD,EAA4D;AAC/DwE,UAAAA,SAAS,CAACxE,IAAD,CAAT,GAAkBvG,IAAI,CAAC6B,SAAL,CAAeuJ,SAAS,CAAC7E,IAAD,CAAxB,EAAgCuB,KAAK,GAAE,CAAvC,CAAlB;AACD,SAFI,CAIL;AAJK,aAKA,IAAI5F,MAAM,CAACkH,wBAAP,CAAgClH,MAAM,CAACkJ,SAAD,CAAtC,EAAmD7E,IAAnD,CAAJ,EAA6D;AAC9DrE,YAAAA,MAAM,CAACC,cAAP,CAAsB4I,SAAtB,EAAiCxE,IAAjC,EAAuCrE,MAAM,CAACkH,wBAAP,CAAgClH,MAAM,CAACkJ,SAAD,CAAtC,EAAmD7E,IAAnD,CAAvC;AACH,WAFI,MAEE;AACHwE,YAAAA,SAAS,CAACxE,IAAD,CAAT,GAAkB6E,SAAS,CAAC7E,IAAD,CAA3B;AACH;AACF;AACF,GAnCD,EAjBoC,CAsDpC;;AACA,SAAOwE,SAAP;AAED,CAzDD;AA2DA;;;;;;;;;;;;AAUA/K,IAAI,CAAC+C,QAAL,GAAgB,UAASyI,GAAT,EAAc;AAC5B,SAAQA,GAAG,KAAK,IAAT,IAAmB,OAAOA,GAAP,KAAe,QAAlC,IAA+C,CAAE7K,KAAK,CAACC,OAAN,CAAc4K,GAAd,CAAxD;AACD,CAFD;AAIA;;;;;;;;;;AAQAxL,IAAI,CAACsJ,SAAL,GAAiB,UAASkC,GAAT,EAAc;AAC7B,SAAOtJ,MAAM,CAAC5B,SAAP,CAAiBmL,QAAjB,CAA0BR,IAA1B,CAA+BO,GAA/B,MAAwC,kBAA/C;AACD,CAFD;AAIA;;;;;;;;;;;;;;;;AAcAxL,IAAI,CAACqB,SAAL,GAAiB,UAAUqK,SAAV,EAAqBC,YAArB,EAAmC;AAClD,MAAI7L,CAAC,GAAG,IAAR,CADkD,CAGlD;;AACA,MAAIiB,KAAK,GAAGf,IAAI,CAACqF,aAAL,CAAmBqG,SAAnB,KAAiCrI,OAAO,CAAC9D,GAAR,CAAYmM,SAAZ,CAAjC,IAA2DC,YAAvE;AACApM,EAAAA,GAAG,CAACmM,SAAD,CAAH,GAAiB3K,KAAjB;AACA,SAAOA,KAAP;AACD,CAPD;AASA;;;;;;;;;;;;;;;;;AAeAf,IAAI,CAACqF,aAAL,GAAqB,UAAUuG,SAAV,EAAqB;AACtC,MAAIC,WAAW,GAAGxI,OAAO,CAACyI,IAAR,CAAa5K,KAAb,CAAmB,CAAnB,EAAsBmC,OAAO,CAACyI,IAAR,CAAa9K,MAAnC,CAAlB;AAAA,MACI+K,OAAO,GAAG,OAAOH,SAAP,GAAmB,GADjC;;AAGA,OAAK,IAAII,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGH,WAAW,CAAC7K,MAA1C,EAAkDgL,MAAM,EAAxD,EAA4D;AAC1D,QAAIH,WAAW,CAACG,MAAD,CAAX,CAAoBzI,OAApB,CAA4BwI,OAA5B,MAAyC,CAA7C,EAAgD;AAC9C,aAAOF,WAAW,CAACG,MAAD,CAAX,CAAoBC,MAApB,CAA2BF,OAAO,CAAC/K,MAAnC,CAAP;AACD;AACF;;AAED,SAAO,KAAP;AACH,CAXD;AAaA;;;;;;;;;;;;;;AAYAhB,IAAI,CAACkM,MAAL,GAAc,UAAUC,OAAV,EAAmB;AAC/B,SAAO5M,GAAG,CAAC4M,OAAD,CAAV;AACD,CAFD;AAMA;;;;;;;;AAMAnM,IAAI,CAAC0I,cAAL,GAAsB,UAAU0D,EAAV,EAAc;AAClC,MAAIC,KAAK,GAAG,EAAZ;AACAD,EAAAA,EAAE,CAACE,MAAH,KAAcD,KAAK,IAAI,GAAvB;AACAD,EAAAA,EAAE,CAACG,UAAH,KAAkBF,KAAK,IAAI,GAA3B;AACAD,EAAAA,EAAE,CAACI,SAAH,KAAiBH,KAAK,IAAI,GAA1B;AACA,SAAOA,KAAP;AACD,CAND;AAQA;;;;;;;;AAMArM,IAAI,CAAC6H,QAAL,GAAgB,UAAStG,MAAT,EAAiB;AAC/B,SAAO0D,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACK,SAAL,CAAe/D,MAAM,IAAI,IAAzB,CAAX,CAAP;AACD,CAFD,C,CAIA;;;AACAvB,IAAI,CAACK,mBAAL,GAA2B,UAAUkB,MAAV,EAAkB;AAC3C,MAAIkL,OAAO,GAAGlL,MAAM,CAACvB,IAAP,CAAYkD,gBAAZ,EAAd;AAEA,MAAIwJ,eAAe,GAAGD,OAAO,CAACrG,GAAR,CAAY,UAAUuG,GAAV,EAAe;AAC/C,WAAOjO,IAAI,CAACkO,QAAL,CAAcD,GAAG,CAAC7L,IAAlB,CAAP;AACD,GAFqB,CAAtB;AAIA9B,EAAAA,QAAQ,CAAC4D,OAAT,CAAiB,UAASrD,GAAT,EAAc;AAC7B;AACA,QAAIsN,gBAAgB,GAAGH,eAAe,CAACI,IAAhB,CAAqB,UAAUC,QAAV,EAAoB;AAC5D,aAAOA,QAAQ,CAACC,KAAT,CAAezN,GAAf,CAAP;AACH,KAFsB,CAAvB,CAF6B,CAK7B;;AACA,QAAIA,GAAG,IAAKA,GAAG,KAAK,aAAhB,IAAkC,CAACsN,gBAAvC,EAAyD;AACvDI,MAAAA,YAAY,CAAC,wBAAsB1N,GAAtB,GAA0B,mDAA3B,CAAZ;AACD,KAR4B,CAS7B;;;AACA,QAAKA,GAAG,KAAK,SAAT,IAAwBA,GAAG,KAAK,OAApC,EAA8C;AAC5C0N,MAAAA,YAAY,CAAC,wBAAsB1N,GAAtB,GAA0B,iBAA3B,CAAZ;AACD;AACF,GAbD,EAP2C,CAsB3C;;AACA,MAAI2N,qBAAqB,GAAGR,eAAe,CAACI,IAAhB,CAAqB,UAAUC,QAAV,EAAoB;AACjE,WAAOA,QAAQ,CAACC,KAAT,CAAe/N,YAAf,CAAP;AACH,GAF2B,CAA5B;;AAGA,MAAIA,YAAY,IAAI,CAACiO,qBAArB,EAA4C;AAC1CD,IAAAA,YAAY,CAAC,iCAA+BhO,YAA/B,GAA4C,iDAA7C,CAAZ;AACD;;AAED,WAASgO,YAAT,CAAuB5C,GAAvB,EAA4B;AAC1B,QAAI8C,QAAQ,GAAG9J,OAAO,CAAC9D,GAAR,CAAY6N,uBAA3B;AACA,QAAIC,MAAM,GAAGF,QAAQ,GAAG,SAAH,GAAe,WAApC;AACA,QAAIG,MAAM,GAAG,+DAAb;AAEA3J,IAAAA,OAAO,CAACwB,KAAR,CAAckI,MAAM,GAAChD,GAArB;AACA1G,IAAAA,OAAO,CAACwB,KAAR,CAAckI,MAAM,GAACC,MAArB,EAN0B,CAQ1B;;AACA,QAAI,CAAC,MAAD,EAAS,GAAT,EAAc/J,OAAd,CAAsB4J,QAAtB,KAAmC,CAAvC,EAA0C;AACxC,YAAM,IAAI/L,KAAJ,CAAUiM,MAAM,GAAChD,GAAP,GAAW,GAAX,GAAeiD,MAAzB,CAAN;AACD;AACF;AACF,CA3CD,C,CA6CA;;;AACA,IAAI/L,MAAM,GAAGgM,MAAM,CAACC,OAAP,GAAiB,IAAI3N,MAAJ,EAA9B,C,CAEA;;AACAG,IAAI,CAACyN,aAAL,GAAqBjP,MAAM,CAACiP,aAA5B;AACAzN,IAAI,CAAC0N,iBAAL,GAAyBlP,MAAM,CAACkP,iBAAhC,C,CAEA;;AACA,IAAIC,YAAY,GAAG,CAAE3N,IAAI,CAACqB,SAAL,CAAe,4BAAf,CAArB;;AACA,IAAIsM,YAAY,IAAIzL,MAAM,CAACM,IAAP,CAAYjB,MAAZ,EAAoBP,MAApB,KAA+B,CAAnD,EAAsD;AACpD2C,EAAAA,OAAO,CAACwB,KAAR,CAAc,iEAAgErG,UAA9E;AACA6E,EAAAA,OAAO,CAACwB,KAAR,CAAc,qFAAd;AACD","sourcesContent":["// config.js (c) 2010-2015 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-config\n\n// Dependencies\nvar deferConfig = require('../defer').deferConfig,\n    DeferredConfig = require('../defer').DeferredConfig,\n    RawConfig = require('../raw').RawConfig,\n    Parser = require('../parser'),\n    Utils = require('util'),\n    Path = require('path'),\n    FileSystem = require('fs');\n\n// Static members\nvar DEFAULT_CLONE_DEPTH = 20,\n    NODE_CONFIG, CONFIG_DIR, RUNTIME_JSON_FILENAME, NODE_ENV, APP_INSTANCE,\n    HOST, HOSTNAME, ALLOW_CONFIG_MUTATIONS, CONFIG_SKIP_GITCRYPT,\n    NODE_CONFIG_PARSER,\n    env = {},\n    privateUtil = {},\n    deprecationWarnings = {},\n    configSources = [],          // Configuration sources - array of {name, original, parsed}\n    checkMutability = true,      // Check for mutability/immutability on first get\n    gitCryptTestRegex = /^.GITCRYPT/; // regular expression to test for gitcrypt files.\n\n/**\n * <p>Application Configurations</p>\n *\n * <p>\n * The config module exports a singleton object representing all\n * configurations for this application deployment.\n * </p>\n *\n * <p>\n * Application configurations are stored in files within the config directory\n * of your application.  The default configuration file is loaded, followed\n * by files specific to the deployment type (development, testing, staging,\n * production, etc.).\n * </p>\n *\n * <p>\n * For example, with the following config/default.yaml file:\n * </p>\n *\n * <pre>\n *   ...\n *   customer:\n *     &nbsp;&nbsp;initialCredit: 500\n *     &nbsp;&nbsp;db:\n *       &nbsp;&nbsp;&nbsp;&nbsp;name: customer\n *       &nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n *   ...\n * </pre>\n *\n * <p>\n * The following code loads the customer section into the CONFIG variable:\n * <p>\n *\n * <pre>\n *   var CONFIG = require('config').customer;\n *   ...\n *   newCustomer.creditLimit = CONFIG.initialCredit;\n *   database.open(CONFIG.db.name, CONFIG.db.port);\n *   ...\n * </pre>\n *\n * @module config\n * @class Config\n */\n\n/**\n * <p>Get the configuration object.</p>\n *\n * <p>\n * The configuration object is a shared singleton object within the application,\n * attained by calling require('config').\n * </p>\n *\n * <p>\n * Usually you'll specify a CONFIG variable at the top of your .js file\n * for file/module scope. If you want the root of the object, you can do this:\n * </p>\n * <pre>\n * var CONFIG = require('config');\n * </pre>\n *\n * <p>\n * Sometimes you only care about a specific sub-object within the CONFIG\n * object.  In that case you could do this at the top of your file:\n * </p>\n * <pre>\n * var CONFIG = require('config').customer;\n * or\n * var CUSTOMER_CONFIG = require('config').customer;\n * </pre>\n *\n * <script type=\"text/javascript\">\n *   document.getElementById(\"showProtected\").style.display = \"block\";\n * </script>\n *\n * @method constructor\n * @return CONFIG {object} - The top level configuration object\n */\nvar Config = function() {\n  var t = this;\n\n  // Bind all utility functions to this\n  for (var fnName in util) {\n    if (typeof util[fnName] === 'function') {\n      util[fnName] = util[fnName].bind(t);\n    }\n  }\n\n  // Merge configurations into this\n  util.extendDeep(t, util.loadFileConfigs());\n  util.attachProtoDeep(t);\n\n  // Perform strictness checks and possibly throw an exception.\n  util.runStrictnessChecks(t);\n};\n\n/**\n * Utilities are under the util namespace vs. at the top level\n */\nvar util = Config.prototype.util = {};\n\n/**\n * Underlying get mechanism\n *\n * @private\n * @method getImpl\n * @param object {object} - Object to get the property for\n * @param property {string|string[]} - The property name to get (as an array or '.' delimited string)\n * @return value {*} - Property value, including undefined if not defined.\n */\nvar getImpl= function(object, property) {\n  var t = this,\n      elems = Array.isArray(property) ? property : property.split('.'),\n      name = elems[0],\n      value = object[name];\n  if (elems.length <= 1) {\n    return value;\n  }\n  // Note that typeof null === 'object'\n  if (value === null || typeof value !== 'object') {\n    return undefined;\n  }\n  return getImpl(value, elems.slice(1));\n};\n\n/**\n * <p>Get a configuration value</p>\n *\n * <p>\n * This will return the specified property value, throwing an exception if the\n * configuration isn't defined.  It is used to assure configurations are defined\n * before being used, and to prevent typos.\n * </p>\n *\n * @method get\n * @param property {string} - The configuration property to get. Can include '.' sub-properties.\n * @return value {*} - The property value\n */\nConfig.prototype.get = function(property) {\n  if(property === null || property === undefined){\n    throw new Error(\"Calling config.get with null or undefined argument\");\n  }\n\n  // Make configurations immutable after first get (unless disabled)\n  if (checkMutability) {\n    if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n      util.makeImmutable(config);\n    }\n    checkMutability = false;\n  }\n  var t = this,\n      value = getImpl(t, property);\n\n  // Produce an exception if the property doesn't exist\n  if (value === undefined) {\n    throw new Error('Configuration property \"' + property + '\" is not defined');\n  }\n\n  // Return the value\n  return value;\n};\n\n/**\n * Test that a configuration parameter exists\n *\n * <pre>\n *    var config = require('config');\n *    if (config.has('customer.dbName')) {\n *      console.log('Customer database name: ' + config.customer.dbName);\n *    }\n * </pre>\n *\n * @method has\n * @param property {string} - The configuration property to test. Can include '.' sub-properties.\n * @return isPresent {boolean} - True if the property is defined, false if not defined.\n */\nConfig.prototype.has = function(property) {\n  // While get() throws an exception for undefined input, has() is designed to test validity, so false is appropriate\n  if(property === null || property === undefined){\n    return false;\n  }\n  var t = this;\n  return (getImpl(t, property) !== undefined);\n};\n\n/**\n * <p>\n * Set default configurations for a node.js module.\n * </p>\n *\n * <p>\n * This allows module developers to attach their configurations onto the\n * default configuration object so they can be configured by the consumers\n * of the module.\n * </p>\n *\n * <p>Using the function within your module:</p>\n * <pre>\n *   var CONFIG = require(\"config\");\n *   CONFIG.util.setModuleDefaults(\"MyModule\", {\n *   &nbsp;&nbsp;templateName: \"t-50\",\n *   &nbsp;&nbsp;colorScheme: \"green\"\n *   });\n * <br>\n *   // Template name may be overridden by application config files\n *   console.log(\"Template: \" + CONFIG.MyModule.templateName);\n * </pre>\n *\n * <p>\n * The above example results in a \"MyModule\" element of the configuration\n * object, containing an object with the specified default values.\n * </p>\n *\n * @method setModuleDefaults\n * @param moduleName {string} - Name of your module.\n * @param defaultProperties {object} - The default module configuration.\n * @return moduleConfig {object} - The module level configuration object.\n */\nutil.setModuleDefaults = function (moduleName, defaultProperties) {\n\n  // Copy the properties into a new object\n  var t = this,\n    moduleConfig = util.cloneDeep(defaultProperties);\n\n  // Set module defaults into the first sources element\n  if (configSources.length === 0 || configSources[0].name !== 'Module Defaults') {\n    configSources.splice(0, 0, {\n      name: 'Module Defaults',\n      parsed: {}\n    });\n  }\n  util.setPath(configSources[0].parsed, moduleName.split('.'), {});\n  util.extendDeep(getImpl(configSources[0].parsed, moduleName), defaultProperties);\n\n  // Create a top level config for this module if it doesn't exist\n  util.setPath(t, moduleName.split('.'), getImpl(t, moduleName) || {});\n\n  // Extend local configurations into the module config\n  util.extendDeep(moduleConfig, getImpl(t, moduleName));\n\n  // Merge the extended configs without replacing the original\n  util.extendDeep(getImpl(t, moduleName), moduleConfig);\n\n  // reset the mutability check for \"config.get\" method.\n  // we are not making t[moduleName] immutable immediately,\n  // since there might be more modifications before the first config.get\n  if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n    checkMutability = true;\n  }\n\n  // Attach handlers & watchers onto the module config object\n  return util.attachProtoDeep(getImpl(t, moduleName));\n};\n\n/**\n * <p>Make a configuration property hidden so it doesn't appear when enumerating\n * elements of the object.</p>\n *\n * <p>\n * The property still exists and can be read from and written to, but it won't\n * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n * </p>\n *\n * <p>\n * If the property already exists, it will be made hidden.  Otherwise it will\n * be created as a hidden property with the specified value.\n * </p>\n *\n * <p><i>\n * This method was built for hiding configuration values, but it can be applied\n * to <u>any</u> javascript object.\n * </i></p>\n *\n * <p>Example:</p>\n * <pre>\n *   var CONFIG = require('config');\n *   ...\n *\n *   // Hide the Amazon S3 credentials\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'access_id');\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'secret_key');\n * </pre>\n *\n * @method makeHidden\n * @param object {object} - The object to make a hidden property into.\n * @param property {string} - The name of the property to make hidden.\n * @param value {*} - (optional) Set the property value to this (otherwise leave alone)\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeHidden = function(object, property, value) {\n\n  // If the new value isn't specified, just mark the property as hidden\n  if (typeof value === 'undefined') {\n    Object.defineProperty(object, property, {\n      enumerable : false\n    });\n  }\n  // Otherwise set the value and mark it as hidden\n  else {\n    Object.defineProperty(object, property, {\n      value      : value,\n      enumerable : false\n    });\n  }\n\n  return object;\n}\n\n/**\n * <p>Make a javascript object property immutable (assuring it cannot be changed\n * from the current value).</p>\n * <p>\n * If the specified property is an object, all attributes of that object are\n * made immutable, including properties of contained objects, recursively.\n * If a property name isn't supplied, all properties of the object are made\n * immutable.\n * </p>\n * <p>\n *\n * </p>\n * <p>\n * New properties can be added to the object and those properties will not be\n * immutable unless this method is called on those new properties.\n * </p>\n * <p>\n * This operation cannot be undone.\n * </p>\n *\n * <p>Example:</p>\n * <pre>\n *   var config = require('config');\n *   var myObject = {hello:'world'};\n *   config.util.makeImmutable(myObject);\n * </pre>\n *\n * @method makeImmutable\n * @param object {object} - The object to specify immutable properties for\n * @param [property] {string | [string]} - The name of the property (or array of names) to make immutable.\n *        If not provided, all owned properties of the object are made immutable.\n * @param [value] {* | [*]} - Property value (or array of values) to set\n *        the property to before making immutable. Only used when setting a single\n *        property. Retained for backward compatibility.\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeImmutable = function(object, property, value) {\n  var properties = null;\n\n  // Backwards compatibility mode where property/value can be specified\n  if (typeof property === 'string') {\n    return Object.defineProperty(object, property, {\n      value : (typeof value === 'undefined') ? object[property] : value,\n      writable : false,\n      configurable: false\n    });\n  }\n\n  // Get the list of properties to work with\n  if (Array.isArray(property)) {\n    properties = property;\n  }\n  else {\n    properties = Object.keys(object);\n  }\n\n  // Process each property\n  for (var i = 0; i < properties.length; i++) {\n    var propertyName = properties[i],\n        value = object[propertyName];\n\n    if (value instanceof RawConfig) {\n      Object.defineProperty(object, propertyName, {\n        value: value.resolve(),\n        writable: false,\n        configurable: false\n      });\n    } else if (Array.isArray(value)) {\n      // Ensure object items of this array are also immutable.\n      value.forEach((item, index) => { if (util.isObject(item) || Array.isArray(item)) util.makeImmutable(item) })\n\n      Object.defineProperty(object, propertyName, {\n        value: Object.freeze(value)\n      });\n    } else {\n      Object.defineProperty(object, propertyName, {\n        value: value,\n        writable : false,\n        configurable: false\n      });\n\n      // Ensure new properties can not be added.\n      Object.preventExtensions(object)\n\n      // Call recursively if an object.\n      if (util.isObject(value)) {\n        util.makeImmutable(value);\n      }\n    }\n  }\n\n  return object;\n};\n\n/**\n * Return the sources for the configurations\n *\n * <p>\n * All sources for configurations are stored in an array of objects containing\n * the source name (usually the filename), the original source (as a string),\n * and the parsed source as an object.\n * </p>\n *\n * @method getConfigSources\n * @return configSources {Array[Object]} - An array of objects containing\n *    name, original, and parsed elements\n */\nutil.getConfigSources = function() {\n  var t = this;\n  return configSources.slice(0);\n};\n\n/**\n * Load the individual file configurations.\n *\n * <p>\n * This method builds a map of filename to the configuration object defined\n * by the file.  The search order is:\n * </p>\n *\n * <pre>\n *   default.EXT\n *   (deployment).EXT\n *   (hostname).EXT\n *   (hostname)-(deployment).EXT\n *   local.EXT\n *   local-(deployment).EXT\n *   runtime.json\n * </pre>\n *\n * <p>\n * EXT can be yml, yaml, coffee, iced, json, cson or js signifying the file type.\n * yaml (and yml) is in YAML format, coffee is a coffee-script, iced is iced-coffee-script,\n * json is in JSON format, cson is in CSON format, properties is in .properties format\n * (http://en.wikipedia.org/wiki/.properties), and js is a javascript executable file that is\n * require()'d with module.exports being the config object.\n * </p>\n *\n * <p>\n * hostname is the $HOST environment variable (or --HOST command line parameter)\n * if set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\n * line parameter) if set, otherwise the hostname found from\n * require('os').hostname().\n * </p>\n *\n * <p>\n * Once a hostname is found, everything from the first period ('.') onwards\n * is removed. For example, abc.example.com becomes abc\n * </p>\n *\n * <p>\n * (deployment) is the deployment type, found in the $NODE_ENV environment\n * variable (which can be overriden by using $NODE_CONFIG_ENV\n * environment variable). Defaults to 'development'.\n * </p>\n *\n * <p>\n * The runtime.json file contains configuration changes made at runtime either\n * manually, or by the application setting a configuration value.\n * </p>\n *\n * <p>\n * If the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\n * command line parameter) is set, then files with this appendage will be loaded.\n * See the Multiple Application Instances section of the main documentaion page\n * for more information.\n * </p>\n *\n * @protected\n * @method loadFileConfigs\n * @return config {Object} The configuration object\n */\nutil.loadFileConfigs = function(configDir) {\n\n  // Initialize\n  var t = this,\n      config = {};\n\n  // Initialize parameters from command line, environment, or default\n  NODE_ENV = util.initParam('NODE_ENV', 'development');\n\n  // Override, NODE_ENV if NODE_CONFIG_ENV is specified.\n  NODE_ENV = util.initParam('NODE_CONFIG_ENV', NODE_ENV);\n\n  // Split files name, for loading multiple files.\n  NODE_ENV = NODE_ENV.split(',');\n\n  CONFIG_DIR = configDir || util.initParam('NODE_CONFIG_DIR', Path.join( process.cwd(), 'config') );\n  if (CONFIG_DIR.indexOf('.') === 0) {\n    CONFIG_DIR = Path.join(process.cwd() , CONFIG_DIR);\n  }\n\n  APP_INSTANCE = util.initParam('NODE_APP_INSTANCE');\n  HOST = util.initParam('HOST');\n  HOSTNAME = util.initParam('HOSTNAME');\n  CONFIG_SKIP_GITCRYPT = util.initParam('CONFIG_SKIP_GITCRYPT');\n\n  // This is for backward compatibility\n  RUNTIME_JSON_FILENAME = util.initParam('NODE_CONFIG_RUNTIME_JSON', Path.join(CONFIG_DIR , 'runtime.json') );\n\n  NODE_CONFIG_PARSER = util.initParam('NODE_CONFIG_PARSER');\n  if (NODE_CONFIG_PARSER) {\n    try {\n      var parserModule = Path.isAbsolute(NODE_CONFIG_PARSER)\n        ? NODE_CONFIG_PARSER\n        : Path.join(CONFIG_DIR, NODE_CONFIG_PARSER);\n      Parser = require(parserModule);\n    }\n    catch (e) {\n      console.warn('Failed to load config parser from ' + NODE_CONFIG_PARSER);\n      console.log(e);\n    }\n  }\n\n  // Determine the host name from the OS module, $HOST, or $HOSTNAME\n  // Remove any . appendages, and default to null if not set\n  try {\n    var hostName = HOST || HOSTNAME;\n\n    if (!hostName) {\n        var OS = require('os');\n        hostName = OS.hostname();\n    }\n  } catch (e) {\n    hostName = '';\n  }\n\n  // Store the hostname that won.\n  env.HOSTNAME = hostName;\n\n  // Read each file in turn\n  var baseNames = ['default'].concat(NODE_ENV);\n\n  // #236: Also add full hostname when they are different.\n  if (hostName) {\n    var firstDomain = hostName.split('.')[0];\n\n    NODE_ENV.forEach(function(env) {\n      // Backward compatibility\n      baseNames.push(firstDomain, firstDomain + '-' + env);\n\n      // Add full hostname when it is not the same\n      if (hostName !== firstDomain) {\n        baseNames.push(hostName, hostName + '-' + env);\n      }\n    });\n  }\n\n  NODE_ENV.forEach(function(env) {\n    baseNames.push('local', 'local-' + env);\n  });\n\n  var allowedFiles = {};\n  var resolutionIndex = 1;\n  var extNames = Parser.getFilesOrder();\n  baseNames.forEach(function(baseName) {\n    extNames.forEach(function(extName) {\n      allowedFiles[baseName + '.' + extName] = resolutionIndex++;\n      if (APP_INSTANCE) {\n        allowedFiles[baseName + '-' + APP_INSTANCE + '.' + extName] = resolutionIndex++;\n      }\n    });\n  });\n\n  var locatedFiles = util.locateMatchingFiles(CONFIG_DIR, allowedFiles);\n  locatedFiles.forEach(function(fullFilename) {\n    var configObj = util.parseFile(fullFilename);\n    if (configObj) {\n      util.extendDeep(config, configObj);\n    }\n  });\n\n  // Override configurations from the $NODE_CONFIG environment variable\n  // NODE_CONFIG only applies to the base config\n  if (!configDir) {\n    var envConfig = {};\n    if (process.env.NODE_CONFIG) {\n      try {\n        envConfig = JSON.parse(process.env.NODE_CONFIG);\n      } catch(e) {\n        console.error('The $NODE_CONFIG environment variable is malformed JSON');\n      }\n      util.extendDeep(config, envConfig);\n      configSources.push({\n        name: \"$NODE_CONFIG\",\n        parsed: envConfig,\n      });\n    }\n\n    // Override configurations from the --NODE_CONFIG command line\n    var cmdLineConfig = util.getCmdLineArg('NODE_CONFIG');\n    if (cmdLineConfig) {\n      try {\n        cmdLineConfig = JSON.parse(cmdLineConfig);\n      } catch(e) {\n        console.error('The --NODE_CONFIG={json} command line argument is malformed JSON');\n      }\n      util.extendDeep(config, cmdLineConfig);\n      configSources.push({\n        name: \"--NODE_CONFIG argument\",\n        parsed: cmdLineConfig,\n      });\n    }\n\n    // Place the mixed NODE_CONFIG into the environment\n    env['NODE_CONFIG'] = JSON.stringify(util.extendDeep(envConfig, cmdLineConfig, {}));\n  }\n\n  // Override with environment variables if there is a custom-environment-variables.EXT mapping file\n  var customEnvVars = util.getCustomEnvVars(CONFIG_DIR, extNames);\n  util.extendDeep(config, customEnvVars);\n\n  // Extend the original config with the contents of runtime.json (backwards compatibility)\n  var runtimeJson = util.parseFile(RUNTIME_JSON_FILENAME) || {};\n  util.extendDeep(config, runtimeJson);\n\n  util.resolveDeferredConfigs(config);\n\n  // Return the configuration object\n  return config;\n};\n\n/**\n * Return a list of fullFilenames who exists in allowedFiles\n * Ordered according to allowedFiles argument specifications\n *\n * @protected\n * @method locateMatchingFiles\n * @param configDirs {string}   the config dir, or multiple dirs separated by a column (:)\n * @param allowedFiles {object} an object. keys and supported filenames\n *                              and values are the position in the resolution order\n * @returns {string[]}          fullFilenames - path + filename\n */\nutil.locateMatchingFiles = function(configDirs, allowedFiles) {\n  return configDirs.split(Path.delimiter)\n    .reduce(function(files, configDir) {\n      if (configDir) {\n        try {\n          FileSystem.readdirSync(configDir).forEach(function(file) {\n            if (allowedFiles[file]) {\n              files.push([allowedFiles[file], Path.join(configDir, file)]);\n            }\n          });\n        }\n        catch(e) {}\n        return files;\n      }\n    }, [])\n    .sort(function(a, b) { return a[0] - b[0]; })\n    .map(function(file) { return file[1]; });\n};\n\n// Using basic recursion pattern, find all the deferred values and resolve them.\nutil.resolveDeferredConfigs = function (config) {\n  var deferred = [];\n\n  function _iterate (prop) {\n\n    // We put the properties we are going to look it in an array to keep the order predictable\n    var propsToSort = [];\n\n    // First step is to put the properties of interest in an array\n    for (var property in prop) {\n      if (prop.hasOwnProperty(property) && prop[property] != null) {\n        propsToSort.push(property);\n      }\n    }\n\n    // Second step is to iterate of the elements in a predictable (sorted) order\n    propsToSort.sort().forEach(function (property) {\n      if (prop[property].constructor === Object) {\n        _iterate(prop[property]);\n      } else if (prop[property].constructor === Array) {\n        for (var i = 0; i < prop[property].length; i++) {\n          if (prop[property][i] instanceof DeferredConfig) {\n            deferred.push(prop[property][i].prepare(config, prop[property], i));\n          }\n          else {\n            _iterate(prop[property][i]);\n          }\n        }\n      } else {\n        if (prop[property] instanceof DeferredConfig) {\n          deferred.push(prop[property].prepare(config, prop, property));\n        }\n        // else: Nothing to do. Keep the property how it is.\n      }\n    });\n  }\n\n  _iterate(config);\n\n  deferred.forEach(function (defer) { defer.resolve(); });\n};\n\n/**\n * Parse and return the specified configuration file.\n *\n * If the file exists in the application config directory, it will\n * parse and return it as a JavaScript object.\n *\n * The file extension determines the parser to use.\n *\n * .js = File to run that has a module.exports containing the config object\n * .coffee = File to run that has a module.exports with coffee-script containing the config object\n * .iced = File to run that has a module.exports with iced-coffee-script containing the config object\n * All other supported file types (yaml, toml, json, cson, hjson, json5, properties, xml)\n * are parsed with util.parseString.\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseFile\n * @param fullFilename {string} The full file path and name\n * @return configObject {object|null} The configuration object parsed from the file\n */\nutil.parseFile = function(fullFilename) {\n  var t = this,  // Initialize\n      configObject = null,\n      fileContent = null,\n      stat = null;\n\n  // Note that all methods here are the Sync versions.  This is appropriate during\n  // module loading (which is a synchronous operation), but not thereafter.\n\n  try {\n    // Try loading the file.\n    fileContent = FileSystem.readFileSync(fullFilename, 'utf-8');\n    fileContent = fileContent.replace(/^\\uFEFF/, '');\n  }\n  catch (e2) {\n    if (e2.code !== 'ENOENT') {\n      throw new Error('Config file ' + fullFilename + ' cannot be read. Error code is: '+e2.code\n                        +'. Error message is: '+e2.message);\n    }\n    return null;  // file doesn't exists\n  }\n\n  // Parse the file based on extension\n  try {\n\n    // skip if it's a gitcrypt file and CONFIG_SKIP_GITCRYPT is true\n    if (CONFIG_SKIP_GITCRYPT) {\n      if (gitCryptTestRegex.test(fileContent)) {\n        console.error('WARNING: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is set. skipping.');\n        return null;\n      }\n    }\n\n    configObject = Parser.parse(fullFilename, fileContent);\n  }\n  catch (e3) {\n    if (gitCryptTestRegex.test(fileContent)) {\n      console.error('ERROR: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is not set.');\n    }\n    throw new Error(\"Cannot parse config file: '\" + fullFilename + \"': \" + e3);\n  }\n\n  // Keep track of this configuration sources, including empty ones\n  if (typeof configObject === 'object') {\n    configSources.push({\n      name: fullFilename,\n      original: fileContent,\n      parsed: configObject,\n    });\n  }\n\n  return configObject;\n};\n\n/**\n * Parse and return the specied string with the specified format.\n *\n * The format determines the parser to use.\n *\n * json = File is parsed using JSON.parse()\n * yaml (or yml) = Parsed with a YAML parser\n * toml = Parsed with a TOML parser\n * cson = Parsed with a CSON parser\n * hjson = Parsed with a HJSON parser\n * json5 = Parsed with a JSON5 parser\n * properties = Parsed with the 'properties' node package\n * xml = Parsed with a XML parser\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseString\n * @param content {string} The full content\n * @param format {string} The format to be parsed\n * @return {configObject} The configuration object parsed from the string\n */\nutil.parseString = function (content, format) {\n  var parser = Parser.getParser(format);\n  if (typeof parser === 'function') {\n    return parser(null, content);\n  }\n};\n\n/**\n * Attach the Config class prototype to all config objects recursively.\n *\n * <p>\n * This allows you to do anything with CONFIG sub-objects as you can do with\n * the top-level CONFIG object.  It's so you can do this:\n * </p>\n *\n * <pre>\n *   var CUST_CONFIG = require('config').Customer;\n *   CUST_CONFIG.get(...)\n * </pre>\n *\n * @protected\n * @method attachProtoDeep\n * @param toObject\n * @param depth\n * @return toObject\n */\nutil.attachProtoDeep = function(toObject, depth) {\n  if (toObject instanceof RawConfig) {\n    return toObject;\n  }\n\n  // Recursion detection\n  var t = this;\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return toObject;\n  }\n\n  // Adding Config.prototype methods directly to toObject as hidden properties\n  // because adding to toObject.__proto__ exposes the function in toObject\n  for (var fnName in Config.prototype) {\n    if (!toObject[fnName]) {\n      util.makeHidden(toObject, fnName, Config.prototype[fnName]);\n    }\n  }\n\n  // Add prototypes to sub-objects\n  for (var prop in toObject) {\n    if (util.isObject(toObject[prop])) {\n      util.attachProtoDeep(toObject[prop], depth - 1);\n    }\n  }\n\n  // Return the original object\n  return toObject;\n};\n\n/**\n * Return a deep copy of the specified object.\n *\n * This returns a new object with all elements copied from the specified\n * object.  Deep copies are made of objects and arrays so you can do anything\n * with the returned object without affecting the input object.\n *\n * @protected\n * @method cloneDeep\n * @param parent {object} The original object to copy from\n * @param [depth=20] {Integer} Maximum depth (default 20)\n * @return {object} A new object with the elements copied from the copyFrom object\n *\n * This method is copied from https://github.com/pvorb/node-clone/blob/17eea36140d61d97a9954c53417d0e04a00525d9/clone.js\n *\n * Copyright © 2011-2014 Paul Vorbach and contributors.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions: The above copyright notice and this permission\n * notice shall be included in all copies or substantial portions of the Software.\n */\nutil.cloneDeep = function cloneDeep(parent, depth, circular, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular === 'undefined')\n    circular = true;\n\n  if (typeof depth === 'undefined')\n    depth = 20;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (Utils.isArray(parent)) {\n      child = [];\n    } else if (Utils.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (Utils.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype === 'undefined') child = Object.create(Object.getPrototypeOf(parent));\n      else child = Object.create(prototype);\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var propDescriptor  = Object.getOwnPropertyDescriptor(parent,i);\n      var hasGetter = ((propDescriptor !== undefined) && (propDescriptor.get !== undefined));\n\n      if (hasGetter){\n        Object.defineProperty(child,i,propDescriptor);\n      } else if (util.isPromise(parent[i])) {\n        child[i] = parent[i];\n      } else {\n        child[i] = _clone(parent[i], depth - 1);\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n};\n\n/**\n * Set objects given a path as a string list\n *\n * @protected\n * @method setPath\n * @param object {object} - Object to set the property on\n * @param path {array[string]} - Array path to the property\n * @param value {*} - value to set, ignoring null\n */\nutil.setPath = function (object, path, value) {\n  var nextKey = null;\n  if (value === null || path.length === 0) {\n    return;\n  }\n  else if (path.length === 1) { // no more keys to make, so set the value\n    object[path.shift()] = value;\n  }\n  else {\n    nextKey = path.shift();\n    if (!object.hasOwnProperty(nextKey)) {\n      object[nextKey] = {};\n    }\n    util.setPath(object[nextKey], path, value);\n  }\n};\n\n/**\n * Create a new object patterned after substitutionMap, where:\n * 1. Terminal string values in substitutionMap are used as keys\n * 2. To look up values in a key-value store, variables\n * 3. And parent keys are created as necessary to retain the structure of substitutionMap.\n *\n * @protected\n * @method substituteDeep\n * @param substitionMap {object} - an object whose terminal (non-subobject) values are strings\n * @param variables {object[string:value]} - usually process.env, a flat object used to transform\n *      terminal values in a copy of substititionMap.\n * @returns {object} - deep copy of substitutionMap with only those paths whose terminal values\n *      corresponded to a key in `variables`\n */\nutil.substituteDeep = function (substitutionMap, variables) {\n  var result = {};\n\n  function _substituteVars(map, vars, pathTo) {\n    for (var prop in map) {\n      var value = map[prop];\n      if (typeof(value) === 'string') { // We found a leaf variable name\n        if (vars[value]) { // if the vars provide a value set the value in the result map\n          util.setPath(result, pathTo.concat(prop), vars[value]);\n        }\n      }\n      else if (util.isObject(value)) { // work on the subtree, giving it a clone of the pathTo\n        if('__name' in value && '__format' in value && vars[value.__name]) {\n          try {\n            var parsedValue = util.parseString(vars[value.__name], value.__format);\n          } catch(err) {\n            err.message = '__format parser error in ' + value.__name + ': ' + err.message;\n            throw err;\n          }\n          util.setPath(result, pathTo.concat(prop), parsedValue);\n        } else {\n          _substituteVars(value, vars, pathTo.concat(prop));\n        }\n      }\n      else {\n        msg = \"Illegal key type for substitution map at \" + pathTo.join('.') + ': ' + typeof(value);\n        throw Error(msg);\n      }\n    }\n  }\n\n  _substituteVars(substitutionMap, variables, []);\n  return result;\n\n};\n\n/* Map environment variables into the configuration if a mapping file,\n * `custom-environment-variables.EXT` exists.\n *\n * @protected\n * @method getCustomEnvVars\n * @param CONFIG_DIR {string} - the passsed configuration directory\n * @param extNames {Array[string]} - acceptable configuration file extension names.\n * @returns {object} - mapped environment variables or {} if there are none\n */\nutil.getCustomEnvVars = function (CONFIG_DIR, extNames) {\n  var result = {};\n  extNames.forEach(function (extName) {\n    var fullFilename = Path.join(CONFIG_DIR , 'custom-environment-variables' + '.' + extName);\n    var configObj = util.parseFile(fullFilename);\n    if (configObj) {\n      var environmentSubstitutions = util.substituteDeep(configObj, process.env);\n      util.extendDeep(result, environmentSubstitutions);\n    }\n  });\n  return result;\n};\n\n/**\n * Return true if two objects have equal contents.\n *\n * @protected\n * @method equalsDeep\n * @param object1 {object} The object to compare from\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {boolean} True if both objects have equivalent contents\n */\nutil.equalsDeep = function(object1, object2, depth) {\n\n  // Recursion detection\n  var t = this;\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return {};\n  }\n\n  // Fast comparisons\n  if (!object1 || !object2) {\n    return false;\n  }\n  if (object1 === object2) {\n    return true;\n  }\n  if (typeof(object1) != 'object' || typeof(object2) != 'object') {\n    return false;\n  }\n\n  // They must have the same keys.  If their length isn't the same\n  // then they're not equal.  If the keys aren't the same, the value\n  // comparisons will fail.\n  if (Object.keys(object1).length != Object.keys(object2).length) {\n    return false;\n  }\n\n  // Compare the values\n  for (var prop in object1) {\n\n    // Call recursively if an object or array\n    if (object1[prop] && typeof(object1[prop]) === 'object') {\n      if (!util.equalsDeep(object1[prop], object2[prop], depth - 1)) {\n        return false;\n      }\n    }\n    else {\n      if (object1[prop] !== object2[prop]) {\n        return false;\n      }\n    }\n  }\n\n  // Test passed.\n  return true;\n};\n\n/**\n * Returns an object containing all elements that differ between two objects.\n * <p>\n * This method was designed to be used to create the runtime.json file\n * contents, but can be used to get the diffs between any two Javascript objects.\n * </p>\n * <p>\n * It works best when object2 originated by deep copying object1, then\n * changes were made to object2, and you want an object that would give you\n * the changes made to object1 which resulted in object2.\n * </p>\n *\n * @protected\n * @method diffDeep\n * @param object1 {object} The base object to compare to\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} A differential object, which if extended onto object1 would\n *                  result in object2.\n */\nutil.diffDeep = function(object1, object2, depth) {\n\n  // Recursion detection\n  var t = this, diff = {};\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return {};\n  }\n\n  // Process each element from object2, adding any element that's different\n  // from object 1.\n  for (var parm in object2) {\n    var value1 = object1[parm];\n    var value2 = object2[parm];\n    if (value1 && value2 && util.isObject(value2)) {\n      if (!(util.equalsDeep(value1, value2))) {\n        diff[parm] = util.diffDeep(value1, value2, depth - 1);\n      }\n    }\n    else if (Array.isArray(value1) && Array.isArray(value2)) {\n      if(!util.equalsDeep(value1, value2)) {\n        diff[parm] = value2;\n      }\n    }\n    else if (value1 !== value2){\n      diff[parm] = value2;\n    }\n  }\n\n  // Return the diff object\n  return diff;\n\n};\n\n/**\n * Extend an object, and any object it contains.\n *\n * This does not replace deep objects, but dives into them\n * replacing individual elements instead.\n *\n * @protected\n * @method extendDeep\n * @param mergeInto {object} The object to merge into\n * @param mergeFrom... {object...} - Any number of objects to merge from\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} The altered mergeInto object is returned\n */\nutil.extendDeep = function(mergeInto) {\n\n  // Initialize\n  var t = this;\n  var vargs = Array.prototype.slice.call(arguments, 1);\n  var depth = vargs.pop();\n  if (typeof(depth) != 'number') {\n    vargs.push(depth);\n    depth = DEFAULT_CLONE_DEPTH;\n  }\n\n  // Recursion detection\n  if (depth < 0) {\n    return mergeInto;\n  }\n\n  // Cycle through each object to extend\n  vargs.forEach(function(mergeFrom) {\n\n    // Cycle through each element of the object to merge from\n    for (var prop in mergeFrom) {\n\n      // save original value in deferred elements\n      var fromIsDeferredFunc = mergeFrom[prop] instanceof DeferredConfig;\n      var isDeferredFunc = mergeInto[prop] instanceof DeferredConfig;\n\n      if (fromIsDeferredFunc && mergeInto.hasOwnProperty(prop)) {\n        mergeFrom[prop]._original = isDeferredFunc ? mergeInto[prop]._original : mergeInto[prop];\n      }\n      // Extend recursively if both elements are objects and target is not really a deferred function\n      if (mergeFrom[prop] instanceof Date) {\n        mergeInto[prop] = mergeFrom[prop];\n      } if (mergeFrom[prop] instanceof RegExp) {\n        mergeInto[prop] = mergeFrom[prop];\n      } else if (util.isObject(mergeInto[prop]) && util.isObject(mergeFrom[prop]) && !isDeferredFunc) {\n        util.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);\n      }\n      else if (util.isPromise(mergeFrom[prop])) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n      // Copy recursively if the mergeFrom element is an object (or array or fn)\n      else if (mergeFrom[prop] && typeof mergeFrom[prop] === 'object') {\n        mergeInto[prop] = util.cloneDeep(mergeFrom[prop], depth -1);\n      }\n\n      // Copy property descriptor otherwise, preserving accessors\n      else if (Object.getOwnPropertyDescriptor(Object(mergeFrom), prop)){\n          Object.defineProperty(mergeInto, prop, Object.getOwnPropertyDescriptor(Object(mergeFrom), prop));\n      } else {\n          mergeInto[prop] = mergeFrom[prop];\n      }\n    }\n  });\n\n  // Chain\n  return mergeInto;\n\n};\n\n/**\n * Is the specified argument a regular javascript object?\n *\n * The argument is an object if it's a JS object, but not an array.\n *\n * @protected\n * @method isObject\n * @param obj {*} An argument of any type.\n * @return {boolean} TRUE if the arg is an object, FALSE if not\n */\nutil.isObject = function(obj) {\n  return (obj !== null) && (typeof obj === 'object') && !(Array.isArray(obj));\n};\n\n/**\n * Is the specified argument a javascript promise?\n *\n * @protected\n * @method isPromise\n * @param obj {*} An argument of any type.\n * @returns {boolean}\n */\nutil.isPromise = function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Promise]';\n};\n\n/**\n * <p>Initialize a parameter from the command line or process environment</p>\n *\n * <p>\n * This method looks for the parameter from the command line in the format\n * --PARAMETER=VALUE, then from the process environment, then from the\n * default specified as an argument.\n * </p>\n *\n * @method initParam\n * @param paramName {String} Name of the parameter\n * @param [defaultValue] {Any} Default value of the parameter\n * @return {Any} The found value, or default value\n */\nutil.initParam = function (paramName, defaultValue) {\n  var t = this;\n\n  // Record and return the value\n  var value = util.getCmdLineArg(paramName) || process.env[paramName] || defaultValue;\n  env[paramName] = value;\n  return value;\n}\n\n/**\n * <p>Get Command Line Arguments</p>\n *\n * <p>\n * This method allows you to retrieve the value of the specified command line argument.\n * </p>\n *\n * <p>\n * The argument is case sensitive, and must be of the form '--ARG_NAME=value'\n * </p>\n *\n * @method getCmdLineArg\n * @param searchFor {String} The argument name to search for\n * @return {*} false if the argument was not found, the argument value if found\n */\nutil.getCmdLineArg = function (searchFor) {\n    var cmdLineArgs = process.argv.slice(2, process.argv.length),\n        argName = '--' + searchFor + '=';\n\n    for (var argvIt = 0; argvIt < cmdLineArgs.length; argvIt++) {\n      if (cmdLineArgs[argvIt].indexOf(argName) === 0) {\n        return cmdLineArgs[argvIt].substr(argName.length);\n      }\n    }\n\n    return false;\n}\n\n/**\n * <p>Get a Config Environment Variable Value</p>\n *\n * <p>\n * This method returns the value of the specified config environment variable,\n * including any defaults or overrides.\n * </p>\n *\n * @method getEnv\n * @param varName {String} The environment variable name\n * @return {String} The value of the environment variable\n */\nutil.getEnv = function (varName) {\n  return env[varName];\n}\n\n\n\n/**\n * Returns a string of flags for regular expression `re`.\n *\n * @param {RegExp} re Regular expression\n * @returns {string} Flags\n */\nutil.getRegExpFlags = function (re) {\n  var flags = '';\n  re.global && (flags += 'g');\n  re.ignoreCase && (flags += 'i');\n  re.multiline && (flags += 'm');\n  return flags;\n};\n\n/**\n * Returns a new deep copy of the current config object, or any part of the config if provided.\n *\n * @param {Object} config The part of the config to copy and serialize. Omit this argument to return the entire config.\n * @returns {Object} The cloned config or part of the config\n */\nutil.toObject = function(config) {\n  return JSON.parse(JSON.stringify(config || this));\n};\n\n// Run strictness checks on NODE_ENV and NODE_APP_INSTANCE and throw an error if there's a problem.\nutil.runStrictnessChecks = function (config) {\n  var sources = config.util.getConfigSources();\n\n  var sourceFilenames = sources.map(function (src) {\n    return Path.basename(src.name);\n  });\n\n  NODE_ENV.forEach(function(env) {\n    // Throw an exception if there's no explicit config file for NODE_ENV\n    var anyFilesMatchEnv = sourceFilenames.some(function (filename) {\n        return filename.match(env);\n    });\n    // development is special-cased because it's the default value\n    if (env && (env !== 'development') && !anyFilesMatchEnv) {\n      _warnOrThrow(\"NODE_ENV value of '\"+env+\"' did not match any deployment config file names.\");\n    }\n    // Throw if NODE_ENV matches' default' or 'local'\n    if ((env === 'default') || (env === 'local')) {\n      _warnOrThrow(\"NODE_ENV value of '\"+env+\"' is ambiguous.\");\n    }\n  });\n\n  // Throw an exception if there's no explict config file for NODE_APP_INSTANCE\n  var anyFilesMatchInstance = sourceFilenames.some(function (filename) {\n      return filename.match(APP_INSTANCE);\n  });\n  if (APP_INSTANCE && !anyFilesMatchInstance) {\n    _warnOrThrow(\"NODE_APP_INSTANCE value of '\"+APP_INSTANCE+\"' did not match any instance config file names.\");\n  }\n\n  function _warnOrThrow (msg) {\n    var beStrict = process.env.NODE_CONFIG_STRICT_MODE;\n    var prefix = beStrict ? 'FATAL: ' : 'WARNING: ';\n    var seeURL = 'See https://github.com/lorenwest/node-config/wiki/Strict-Mode';\n\n    console.error(prefix+msg);\n    console.error(prefix+seeURL);\n\n    // Accept 1 and true as truthy values. When set via process.env, Node.js casts them to strings.\n    if ([\"true\", \"1\"].indexOf(beStrict) >= 0) {\n      throw new Error(prefix+msg+' '+seeURL);\n    }\n  }\n};\n\n// Instantiate and export the configuration\nvar config = module.exports = new Config();\n\n// copy methods to util for backwards compatibility\nutil.stripComments = Parser.stripComments;\nutil.stripYamlComments = Parser.stripYamlComments;\n\n// Produce warnings if the configuration is empty\nvar showWarnings = !(util.initParam('SUPPRESS_NO_CONFIG_WARNING'));\nif (showWarnings && Object.keys(config).length === 0) {\n  console.error('WARNING: No configurations found in configuration directory:' +CONFIG_DIR);\n  console.error('WARNING: To disable this warning set SUPPRESS_NO_CONFIG_WARNING in the environment.');\n}\n"]},"metadata":{},"sourceType":"script"}