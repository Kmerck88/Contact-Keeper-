{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nfunction getDataMapKey(path, location) {\n  return `${location}:${path}`;\n}\n\nclass Context {\n  constructor(fields, locations, stack, optional, message) {\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n\n  get errors() {\n    return this._errors;\n  }\n\n  getData(options = {\n    requiredOnly: false\n  }) {\n    // Have to store this.optional in a const otherwise TS thinks the value could have changed\n    // when the functions below run\n    const {\n      optional\n    } = this;\n    const checks = options.requiredOnly && optional ? [value => value !== undefined, value => optional.nullable ? value != null : true, value => optional.checkFalsy ? value : true] : [];\n    return _([...this.dataMap.values()]).groupBy('originalPath').flatMap((instances, group) => {\n      const locations = _.uniqBy(instances, 'location'); // #331 - When multiple locations are involved, all of them must pass the validation.\n      // If none of the locations contain the field, we at least include one for error reporting.\n      // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n      // paths, so we may want to skip this filtering.\n\n\n      if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n        const withValue = instances.filter(instance => instance.value !== undefined);\n        return withValue.length ? withValue : [instances[0]];\n      }\n\n      return instances;\n    }).filter(instance => checks.every(check => check(instance.value))).valueOf();\n  }\n\n  addFieldInstances(instances) {\n    instances.forEach(instance => {\n      this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n    });\n  }\n\n  setData(path, value, location) {\n    const instance = this.dataMap.get(getDataMapKey(path, location));\n\n    if (!instance) {\n      throw new Error('Attempt to write data that did not pre-exist in context');\n    }\n\n    instance.value = value;\n  }\n\n  addError(message, valueOrNestedErrors, meta) {\n    const msg = message || this.message || 'Invalid value';\n\n    if (meta) {\n      this._errors.push({\n        value: valueOrNestedErrors,\n        msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n        param: meta.path,\n        location: meta.location\n      });\n    } else {\n      this._errors.push({\n        msg,\n        param: '_error',\n        nestedErrors: valueOrNestedErrors\n      });\n    }\n  }\n\n}\n\nexports.Context = Context;","map":{"version":3,"sources":["C:/Users/kevin/Documents/Web Development Projects/Contact-Keeper-/node_modules/express-validator/src/context.js"],"names":["Object","defineProperty","exports","value","_","require","getDataMapKey","path","location","Context","constructor","fields","locations","stack","optional","message","_errors","dataMap","Map","errors","getData","options","requiredOnly","checks","undefined","nullable","checkFalsy","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","addFieldInstances","forEach","set","assign","setData","get","Error","addError","valueOrNestedErrors","meta","msg","push","param","nestedErrors"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n    return `${location}:${path}`;\n}\nclass Context {\n    constructor(fields, locations, stack, optional, message) {\n        this.fields = fields;\n        this.locations = locations;\n        this.stack = stack;\n        this.optional = optional;\n        this.message = message;\n        this._errors = [];\n        this.dataMap = new Map();\n    }\n    get errors() {\n        return this._errors;\n    }\n    getData(options = { requiredOnly: false }) {\n        // Have to store this.optional in a const otherwise TS thinks the value could have changed\n        // when the functions below run\n        const { optional } = this;\n        const checks = options.requiredOnly && optional\n            ? [\n                (value) => value !== undefined,\n                (value) => (optional.nullable ? value != null : true),\n                (value) => (optional.checkFalsy ? value : true),\n            ]\n            : [];\n        return _([...this.dataMap.values()])\n            .groupBy('originalPath')\n            .flatMap((instances, group) => {\n            const locations = _.uniqBy(instances, 'location');\n            // #331 - When multiple locations are involved, all of them must pass the validation.\n            // If none of the locations contain the field, we at least include one for error reporting.\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n            // paths, so we may want to skip this filtering.\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n                const withValue = instances.filter(instance => instance.value !== undefined);\n                return withValue.length ? withValue : [instances[0]];\n            }\n            return instances;\n        })\n            .filter(instance => checks.every(check => check(instance.value)))\n            .valueOf();\n    }\n    addFieldInstances(instances) {\n        instances.forEach(instance => {\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n        });\n    }\n    setData(path, value, location) {\n        const instance = this.dataMap.get(getDataMapKey(path, location));\n        if (!instance) {\n            throw new Error('Attempt to write data that did not pre-exist in context');\n        }\n        instance.value = value;\n    }\n    addError(message, valueOrNestedErrors, meta) {\n        const msg = message || this.message || 'Invalid value';\n        if (meta) {\n            this._errors.push({\n                value: valueOrNestedErrors,\n                msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n                param: meta.path,\n                location: meta.location,\n            });\n        }\n        else {\n            this._errors.push({\n                msg,\n                param: '_error',\n                nestedErrors: valueOrNestedErrors,\n            });\n        }\n    }\n}\nexports.Context = Context;\n"]},"metadata":{},"sourceType":"script"}