{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chain_1 = require(\"../chain\");\n\nconst check_1 = require(\"./check\");\n\nconst validLocations = ['body', 'cookies', 'headers', 'params', 'query'];\nconst protectedNames = ['errorMessage', 'in'];\n\nfunction checkSchema(schema, defaultLocations = validLocations) {\n  return Object.keys(schema).map(field => {\n    const config = schema[field];\n    const chain = check_1.check(field, ensureLocations(config, defaultLocations), config.errorMessage);\n    Object.keys(config).filter(method => {\n      return config[method] && !protectedNames.includes(method);\n    }).forEach(method => {\n      if (typeof chain[method] !== 'function') {\n        console.warn(`express-validator: a validator/sanitizer with name ${method} does not exist`);\n        return;\n      } // Using \"!\" because typescript doesn't know it isn't undefined.\n\n\n      const methodCfg = config[method];\n      let options = methodCfg === true ? [] : methodCfg.options || [];\n\n      if (options != null && !Array.isArray(options)) {\n        options = [options];\n      }\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.negated) {\n        chain.not();\n      }\n\n      chain[method](...options);\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.errorMessage) {\n        chain.withMessage(methodCfg.errorMessage);\n      }\n    });\n    return chain;\n  });\n}\n\nexports.checkSchema = checkSchema;\n\nfunction isValidatorOptions(method, methodCfg) {\n  return methodCfg !== true && method in chain_1.ValidatorsImpl.prototype;\n}\n\nfunction ensureLocations(config, defaults) {\n  // .filter(Boolean) is done because in can be undefined -- which is not going away from the type\n  // See https://github.com/Microsoft/TypeScript/pull/29955 for details\n  const locations = Array.isArray(config.in) ? config.in : [config.in].filter(Boolean);\n  const actualLocations = locations.length ? locations : defaults;\n  return actualLocations.filter(location => validLocations.includes(location));\n}","map":{"version":3,"sources":["C:/Users/kevin/Documents/Web Development Projects/Contact-Keeper-/node_modules/express-validator/src/middlewares/schema.js"],"names":["Object","defineProperty","exports","value","chain_1","require","check_1","validLocations","protectedNames","checkSchema","schema","defaultLocations","keys","map","field","config","chain","check","ensureLocations","errorMessage","filter","method","includes","forEach","console","warn","methodCfg","options","Array","isArray","isValidatorOptions","negated","not","withMessage","ValidatorsImpl","prototype","defaults","locations","in","Boolean","actualLocations","length","location"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chain_1 = require(\"../chain\");\nconst check_1 = require(\"./check\");\nconst validLocations = ['body', 'cookies', 'headers', 'params', 'query'];\nconst protectedNames = ['errorMessage', 'in'];\nfunction checkSchema(schema, defaultLocations = validLocations) {\n    return Object.keys(schema).map(field => {\n        const config = schema[field];\n        const chain = check_1.check(field, ensureLocations(config, defaultLocations), config.errorMessage);\n        Object.keys(config)\n            .filter((method) => {\n            return config[method] && !protectedNames.includes(method);\n        })\n            .forEach(method => {\n            if (typeof chain[method] !== 'function') {\n                console.warn(`express-validator: a validator/sanitizer with name ${method} does not exist`);\n                return;\n            }\n            // Using \"!\" because typescript doesn't know it isn't undefined.\n            const methodCfg = config[method];\n            let options = methodCfg === true ? [] : methodCfg.options || [];\n            if (options != null && !Array.isArray(options)) {\n                options = [options];\n            }\n            if (isValidatorOptions(method, methodCfg) && methodCfg.negated) {\n                chain.not();\n            }\n            chain[method](...options);\n            if (isValidatorOptions(method, methodCfg) && methodCfg.errorMessage) {\n                chain.withMessage(methodCfg.errorMessage);\n            }\n        });\n        return chain;\n    });\n}\nexports.checkSchema = checkSchema;\nfunction isValidatorOptions(method, methodCfg) {\n    return methodCfg !== true && method in chain_1.ValidatorsImpl.prototype;\n}\nfunction ensureLocations(config, defaults) {\n    // .filter(Boolean) is done because in can be undefined -- which is not going away from the type\n    // See https://github.com/Microsoft/TypeScript/pull/29955 for details\n    const locations = Array.isArray(config.in)\n        ? config.in\n        : [config.in].filter(Boolean);\n    const actualLocations = locations.length ? locations : defaults;\n    return actualLocations.filter(location => validLocations.includes(location));\n}\n"]},"metadata":{},"sourceType":"script"}