<<<<<<< HEAD
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";

var Range = /*#__PURE__*/function () {
  _createClass(Range, null, [{
=======
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Range =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(Range, null, [{
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    key: "copy",
    value: function copy(orig) {
      return new Range(orig.start, orig.end);
    }
  }]);

  function Range(start, end) {
<<<<<<< HEAD
    _classCallCheck(this, Range);

=======
    (0, _classCallCheck2.default)(this, Range);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    this.start = start;
    this.end = end || start;
  }

<<<<<<< HEAD
  _createClass(Range, [{
=======
  (0, _createClass2.default)(Range, [{
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    key: "isEmpty",
    value: function isEmpty() {
      return typeof this.start !== 'number' || !this.end || this.end <= this.start;
    }
    /**
     * Set `origStart` and `origEnd` to point to the original source range for
     * this node, which may differ due to dropped CR characters.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */

  }, {
    key: "setOrigRange",
    value: function setOrigRange(cr, offset) {
      var start = this.start,
          end = this.end;

      if (cr.length === 0 || end <= cr[0]) {
        this.origStart = start;
        this.origEnd = end;
        return offset;
      }

      var i = offset;

      while (i < cr.length) {
        if (cr[i] > start) break;else ++i;
      }

      this.origStart = start + i;
      var nextOffset = i;

      while (i < cr.length) {
        // if end was at \n, it should now be at \r
        if (cr[i] >= end) break;else ++i;
      }

      this.origEnd = end + i;
      return nextOffset;
    }
  }]);
<<<<<<< HEAD

  return Range;
}();

export { Range as default };
=======
  return Range;
}();

exports.default = Range;
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
