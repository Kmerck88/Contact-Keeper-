<<<<<<< HEAD
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
import { Type } from '../constants';
import { YAMLSemanticError } from '../errors';
import BlankLine from './BlankLine';
import Node from './Node';
import Range from './Range';

var CollectionItem = /*#__PURE__*/function (_Node) {
  _inherits(CollectionItem, _Node);
=======
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _constants = require("../constants");

var _errors = require("../errors");

var _BlankLine = _interopRequireDefault(require("./BlankLine"));

var _Node2 = _interopRequireDefault(require("./Node"));

var _Range = _interopRequireDefault(require("./Range"));

var CollectionItem =
/*#__PURE__*/
function (_Node) {
  (0, _inherits2.default)(CollectionItem, _Node);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0

  function CollectionItem(type, props) {
    var _this;

<<<<<<< HEAD
    _classCallCheck(this, CollectionItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CollectionItem).call(this, type, props));
=======
    (0, _classCallCheck2.default)(this, CollectionItem);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CollectionItem).call(this, type, props));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    _this.node = null;
    return _this;
  }

<<<<<<< HEAD
  _createClass(CollectionItem, [{
=======
  (0, _createClass2.default)(CollectionItem, [{
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    key: "parse",

    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
    value: function parse(context, start) {
      this.context = context;
      var parseNode = context.parseNode,
          src = context.src;
      var atLineStart = context.atLineStart,
          lineStart = context.lineStart;
<<<<<<< HEAD
      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
      var indent = atLineStart ? start - lineStart : context.indent;
      var offset = Node.endOfWhiteSpace(src, start + 1);
=======
      if (!atLineStart && this.type === _constants.Type.SEQ_ITEM) this.error = new _errors.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
      var indent = atLineStart ? start - lineStart : context.indent;

      var offset = _Node2.default.endOfWhiteSpace(src, start + 1);

>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
      var ch = src[offset];
      var inlineComment = ch === '#';
      var comments = [];
      var blankLine = null;

      while (ch === '\n' || ch === '#') {
        if (ch === '#') {
<<<<<<< HEAD
          var _end = Node.endOfLine(src, offset + 1);

          comments.push(new Range(offset, _end));
=======
          var _end = _Node2.default.endOfLine(src, offset + 1);

          comments.push(new _Range.default(offset, _end));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
          offset = _end;
        } else {
          atLineStart = true;
          lineStart = offset + 1;
<<<<<<< HEAD
          var wsEnd = Node.endOfWhiteSpace(src, lineStart);

          if (src[wsEnd] === '\n' && comments.length === 0) {
            blankLine = new BlankLine();
=======

          var wsEnd = _Node2.default.endOfWhiteSpace(src, lineStart);

          if (src[wsEnd] === '\n' && comments.length === 0) {
            blankLine = new _BlankLine.default();
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
            lineStart = blankLine.parse({
              src: src
            }, lineStart);
          }

<<<<<<< HEAD
          offset = Node.endOfIndent(src, lineStart);
=======
          offset = _Node2.default.endOfIndent(src, lineStart);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        }

        ch = src[offset];
      }

<<<<<<< HEAD
      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
=======
      if (_Node2.default.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== _constants.Type.SEQ_ITEM)) {
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        this.node = parseNode({
          atLineStart: atLineStart,
          inCollection: false,
          indent: indent,
          lineStart: lineStart,
          parent: this
        }, offset);
      } else if (ch && lineStart > start + 1) {
        offset = lineStart - 1;
      }

      if (this.node) {
        if (blankLine) {
          // Only blank lines preceding non-empty nodes are captured. Note that
          // this means that collection item range start indices do not always
          // increase monotonically. -- eemeli/yaml#126
          var items = context.parent.items || context.parent.contents;
          if (items) items.push(blankLine);
        }

        if (comments.length) Array.prototype.push.apply(this.props, comments);
        offset = this.node.range.end;
      } else {
        if (inlineComment) {
          var c = comments[0];
          this.props.push(c);
          offset = c.end;
        } else {
<<<<<<< HEAD
          offset = Node.endOfLine(src, start + 1);
=======
          offset = _Node2.default.endOfLine(src, start + 1);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        }
      }

      var end = this.node ? this.node.valueRange.end : offset;
<<<<<<< HEAD
      this.valueRange = new Range(start, end);
=======
      this.valueRange = new _Range.default(start, end);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
      return offset;
    }
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset) {
<<<<<<< HEAD
      offset = _get(_getPrototypeOf(CollectionItem.prototype), "setOrigRanges", this).call(this, cr, offset);
=======
      offset = (0, _get2.default)((0, _getPrototypeOf2.default)(CollectionItem.prototype), "setOrigRanges", this).call(this, cr, offset);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
      return this.node ? this.node.setOrigRanges(cr, offset) : offset;
    }
  }, {
    key: "toString",
    value: function toString() {
      var src = this.context.src,
          node = this.node,
          range = this.range,
          value = this.value;
      if (value != null) return value;
      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
<<<<<<< HEAD
      return Node.addStringTerminator(src, range.end, str);
=======
      return _Node2.default.addStringTerminator(src, range.end, str);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    }
  }, {
    key: "includesTrailingLines",
    get: function get() {
      return !!this.node && this.node.includesTrailingLines;
    }
  }]);
<<<<<<< HEAD

  return CollectionItem;
}(Node);

export { CollectionItem as default };
=======
  return CollectionItem;
}(_Node2.default);

exports.default = CollectionItem;
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
