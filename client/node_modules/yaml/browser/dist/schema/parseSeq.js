<<<<<<< HEAD
import { Type } from '../constants';
import { YAMLSemanticError, YAMLSyntaxError, YAMLWarning } from '../errors';
import Pair from './Pair';
import { checkFlowCollectionEnd, checkKeyLength, resolveComments } from './parseUtils';
import Seq from './Seq';
import Collection from './Collection';
export default function parseSeq(doc, cst) {
  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }

  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),
      comments = _ref.comments,
      items = _ref.items;

  var seq = new Seq();
  seq.items = items;
  resolveComments(seq, comments);

  if (!doc.options.mapAsMap && items.some(function (it) {
    return it instanceof Pair && it.key instanceof Collection;
  })) {
    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new YAMLWarning(cst, warn));
=======
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseSeq;

var _constants = require("../constants");

var _errors = require("../errors");

var _Pair = _interopRequireDefault(require("./Pair"));

var _parseUtils = require("./parseUtils");

var _Seq = _interopRequireDefault(require("./Seq"));

var _Collection = _interopRequireDefault(require("./Collection"));

function parseSeq(doc, cst) {
  if (cst.type !== _constants.Type.SEQ && cst.type !== _constants.Type.FLOW_SEQ) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
    doc.errors.push(new _errors.YAMLSyntaxError(cst, msg));
    return null;
  }

  var _ref = cst.type === _constants.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),
      comments = _ref.comments,
      items = _ref.items;

  var seq = new _Seq.default();
  seq.items = items;
  (0, _parseUtils.resolveComments)(seq, comments);

  if (!doc.options.mapAsMap && items.some(function (it) {
    return it instanceof _Pair.default && it.key instanceof _Collection.default;
  })) {
    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new _errors.YAMLWarning(cst, warn));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
  }

  cst.resolved = seq;
  return seq;
}

function resolveBlockSeqItems(doc, cst) {
  var comments = [];
  var items = [];

  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];

    switch (item.type) {
<<<<<<< HEAD
      case Type.BLANK_LINE:
=======
      case _constants.Type.BLANK_LINE:
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        comments.push({
          before: items.length
        });
        break;

<<<<<<< HEAD
      case Type.COMMENT:
=======
      case _constants.Type.COMMENT:
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;

<<<<<<< HEAD
      case Type.SEQ_ITEM:
=======
      case _constants.Type.SEQ_ITEM:
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        if (item.error) doc.errors.push(item.error);
        items.push(doc.resolveNode(item.node));

        if (item.hasProps) {
          var msg = 'Sequence items cannot have tags or anchors before the - indicator';
<<<<<<< HEAD
          doc.errors.push(new YAMLSemanticError(item, msg));
=======
          doc.errors.push(new _errors.YAMLSemanticError(item, msg));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        }

        break;

      default:
        if (item.error) doc.errors.push(item.error);
<<<<<<< HEAD
        doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
=======
        doc.errors.push(new _errors.YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
    }
  }

  return {
    comments: comments,
    items: items
  };
}

function resolveFlowSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  var explicitKey = false;
  var key = undefined;
  var keyStart = null;
  var next = '[';

  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];

    if (typeof item.char === 'string') {
      var char = item.char,
          offset = item.offset;

      if (char !== ':' && (explicitKey || key !== undefined)) {
        if (explicitKey && key === undefined) key = next ? items.pop() : null;
<<<<<<< HEAD
        items.push(new Pair(key));
=======
        items.push(new _Pair.default(key));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        explicitKey = false;
        key = undefined;
        keyStart = null;
      }

      if (char === next) {
        next = null;
      } else if (!next && char === '?') {
        explicitKey = true;
      } else if (next !== '[' && char === ':' && key === undefined) {
        if (next === ',') {
          key = items.pop();

<<<<<<< HEAD
          if (key instanceof Pair) {
            var msg = 'Chaining flow sequence pairs is invalid';
            var err = new YAMLSemanticError(cst, msg);
=======
          if (key instanceof _Pair.default) {
            var msg = 'Chaining flow sequence pairs is invalid';
            var err = new _errors.YAMLSemanticError(cst, msg);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
            err.offset = offset;
            doc.errors.push(err);
          }

<<<<<<< HEAD
          if (!explicitKey) checkKeyLength(doc.errors, cst, i, key, keyStart);
=======
          if (!explicitKey) (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        } else {
          key = null;
        }

        keyStart = null;
        explicitKey = false; // TODO: add error for non-explicit multiline plain key

        next = null;
      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
        var _msg = "Flow sequence contains an unexpected ".concat(char);

<<<<<<< HEAD
        var _err = new YAMLSyntaxError(cst, _msg);
=======
        var _err = new _errors.YAMLSyntaxError(cst, _msg);
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0

        _err.offset = offset;
        doc.errors.push(_err);
      }
<<<<<<< HEAD
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
=======
    } else if (item.type === _constants.Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === _constants.Type.COMMENT) {
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        var _msg2 = "Expected a ".concat(next, " in flow sequence");

<<<<<<< HEAD
        doc.errors.push(new YAMLSemanticError(item, _msg2));
=======
        doc.errors.push(new _errors.YAMLSemanticError(item, _msg2));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
      }

      var value = doc.resolveNode(item);

      if (key === undefined) {
        items.push(value);
      } else {
<<<<<<< HEAD
        items.push(new Pair(key, value));
=======
        items.push(new _Pair.default(key, value));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
        key = undefined;
      }

      keyStart = item.range.start;
      next = ',';
    }
  }

<<<<<<< HEAD
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
=======
  (0, _parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
  if (key !== undefined) items.push(new _Pair.default(key));
>>>>>>> 087c3e111e0f389a3f9a8381d37edf4f644326b0
  return {
    comments: comments,
    items: items
  };
}